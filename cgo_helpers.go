// WARNING: This file has automatically been generated on Tue, 27 Apr 2021 14:34:23 PDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package arss

/*
#cgo pkg-config: fftw3
#include "util.h"
#include "image_io.h"
#include "sound_io.h"
#include "dsp.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// alloc_DarwinPthreadAttrMemory allocates memory for type C.__darwin_pthread_attr_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadAttrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadAttrValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadAttrValue = unsafe.Sizeof([1]C.__darwin_pthread_attr_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadAttr) Ref() *C.__darwin_pthread_attr_t {
	if x == nil {
		return nil
	}
	return x.ref8274dce0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadAttr) Free() {
	if x != nil && x.allocs8274dce0 != nil {
		x.allocs8274dce0.(*cgoAllocMap).Free()
		x.ref8274dce0 = nil
	}
}

// New_DarwinPthreadAttrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadAttrRef(ref unsafe.Pointer) *_DarwinPthreadAttr {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadAttr)
	obj.ref8274dce0 = (*C.__darwin_pthread_attr_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadAttr) PassRef() (*C.__darwin_pthread_attr_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8274dce0 != nil {
		return x.ref8274dce0, nil
	}
	mem8274dce0 := alloc_DarwinPthreadAttrMemory(1)
	ref8274dce0 := (*C.__darwin_pthread_attr_t)(mem8274dce0)
	allocs8274dce0 := new(cgoAllocMap)
	allocs8274dce0.Add(mem8274dce0)

	var c__sig_allocs *cgoAllocMap
	ref8274dce0.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocs8274dce0.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	ref8274dce0.__opaque, c__opaque_allocs = *(*[56]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocs8274dce0.Borrow(c__opaque_allocs)

	x.ref8274dce0 = ref8274dce0
	x.allocs8274dce0 = allocs8274dce0
	return ref8274dce0, allocs8274dce0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadAttr) PassValue() (C.__darwin_pthread_attr_t, *cgoAllocMap) {
	if x.ref8274dce0 != nil {
		return *x.ref8274dce0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadAttr) Deref() {
	if x.ref8274dce0 == nil {
		return
	}
	x._Sig = (int32)(x.ref8274dce0.__sig)
	x._Opaque = *(*[56]byte)(unsafe.Pointer(&x.ref8274dce0.__opaque))
}

// alloc_DarwinPthreadCondMemory allocates memory for type C.__darwin_pthread_cond_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadCondMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadCondValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadCondValue = unsafe.Sizeof([1]C.__darwin_pthread_cond_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadCond) Ref() *C.__darwin_pthread_cond_t {
	if x == nil {
		return nil
	}
	return x.refff83b341
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadCond) Free() {
	if x != nil && x.allocsff83b341 != nil {
		x.allocsff83b341.(*cgoAllocMap).Free()
		x.refff83b341 = nil
	}
}

// New_DarwinPthreadCondRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadCondRef(ref unsafe.Pointer) *_DarwinPthreadCond {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadCond)
	obj.refff83b341 = (*C.__darwin_pthread_cond_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadCond) PassRef() (*C.__darwin_pthread_cond_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff83b341 != nil {
		return x.refff83b341, nil
	}
	memff83b341 := alloc_DarwinPthreadCondMemory(1)
	refff83b341 := (*C.__darwin_pthread_cond_t)(memff83b341)
	allocsff83b341 := new(cgoAllocMap)
	allocsff83b341.Add(memff83b341)

	var c__sig_allocs *cgoAllocMap
	refff83b341.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocsff83b341.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	refff83b341.__opaque, c__opaque_allocs = *(*[40]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocsff83b341.Borrow(c__opaque_allocs)

	x.refff83b341 = refff83b341
	x.allocsff83b341 = allocsff83b341
	return refff83b341, allocsff83b341

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadCond) PassValue() (C.__darwin_pthread_cond_t, *cgoAllocMap) {
	if x.refff83b341 != nil {
		return *x.refff83b341, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadCond) Deref() {
	if x.refff83b341 == nil {
		return
	}
	x._Sig = (int32)(x.refff83b341.__sig)
	x._Opaque = *(*[40]byte)(unsafe.Pointer(&x.refff83b341.__opaque))
}

// alloc_DarwinPthreadCondattrMemory allocates memory for type C.__darwin_pthread_condattr_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadCondattrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadCondattrValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadCondattrValue = unsafe.Sizeof([1]C.__darwin_pthread_condattr_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadCondattr) Ref() *C.__darwin_pthread_condattr_t {
	if x == nil {
		return nil
	}
	return x.ref1f4b9d9e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadCondattr) Free() {
	if x != nil && x.allocs1f4b9d9e != nil {
		x.allocs1f4b9d9e.(*cgoAllocMap).Free()
		x.ref1f4b9d9e = nil
	}
}

// New_DarwinPthreadCondattrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadCondattrRef(ref unsafe.Pointer) *_DarwinPthreadCondattr {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadCondattr)
	obj.ref1f4b9d9e = (*C.__darwin_pthread_condattr_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadCondattr) PassRef() (*C.__darwin_pthread_condattr_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1f4b9d9e != nil {
		return x.ref1f4b9d9e, nil
	}
	mem1f4b9d9e := alloc_DarwinPthreadCondattrMemory(1)
	ref1f4b9d9e := (*C.__darwin_pthread_condattr_t)(mem1f4b9d9e)
	allocs1f4b9d9e := new(cgoAllocMap)
	allocs1f4b9d9e.Add(mem1f4b9d9e)

	var c__sig_allocs *cgoAllocMap
	ref1f4b9d9e.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocs1f4b9d9e.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	ref1f4b9d9e.__opaque, c__opaque_allocs = *(*[8]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocs1f4b9d9e.Borrow(c__opaque_allocs)

	x.ref1f4b9d9e = ref1f4b9d9e
	x.allocs1f4b9d9e = allocs1f4b9d9e
	return ref1f4b9d9e, allocs1f4b9d9e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadCondattr) PassValue() (C.__darwin_pthread_condattr_t, *cgoAllocMap) {
	if x.ref1f4b9d9e != nil {
		return *x.ref1f4b9d9e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadCondattr) Deref() {
	if x.ref1f4b9d9e == nil {
		return
	}
	x._Sig = (int32)(x.ref1f4b9d9e.__sig)
	x._Opaque = *(*[8]byte)(unsafe.Pointer(&x.ref1f4b9d9e.__opaque))
}

// alloc_DarwinPthreadMutexMemory allocates memory for type C.__darwin_pthread_mutex_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadMutexMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadMutexValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadMutexValue = unsafe.Sizeof([1]C.__darwin_pthread_mutex_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadMutex) Ref() *C.__darwin_pthread_mutex_t {
	if x == nil {
		return nil
	}
	return x.refafa2b7f7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadMutex) Free() {
	if x != nil && x.allocsafa2b7f7 != nil {
		x.allocsafa2b7f7.(*cgoAllocMap).Free()
		x.refafa2b7f7 = nil
	}
}

// New_DarwinPthreadMutexRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadMutexRef(ref unsafe.Pointer) *_DarwinPthreadMutex {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadMutex)
	obj.refafa2b7f7 = (*C.__darwin_pthread_mutex_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadMutex) PassRef() (*C.__darwin_pthread_mutex_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refafa2b7f7 != nil {
		return x.refafa2b7f7, nil
	}
	memafa2b7f7 := alloc_DarwinPthreadMutexMemory(1)
	refafa2b7f7 := (*C.__darwin_pthread_mutex_t)(memafa2b7f7)
	allocsafa2b7f7 := new(cgoAllocMap)
	allocsafa2b7f7.Add(memafa2b7f7)

	var c__sig_allocs *cgoAllocMap
	refafa2b7f7.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocsafa2b7f7.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	refafa2b7f7.__opaque, c__opaque_allocs = *(*[56]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocsafa2b7f7.Borrow(c__opaque_allocs)

	x.refafa2b7f7 = refafa2b7f7
	x.allocsafa2b7f7 = allocsafa2b7f7
	return refafa2b7f7, allocsafa2b7f7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadMutex) PassValue() (C.__darwin_pthread_mutex_t, *cgoAllocMap) {
	if x.refafa2b7f7 != nil {
		return *x.refafa2b7f7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadMutex) Deref() {
	if x.refafa2b7f7 == nil {
		return
	}
	x._Sig = (int32)(x.refafa2b7f7.__sig)
	x._Opaque = *(*[56]byte)(unsafe.Pointer(&x.refafa2b7f7.__opaque))
}

// alloc_DarwinPthreadMutexattrMemory allocates memory for type C.__darwin_pthread_mutexattr_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadMutexattrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadMutexattrValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadMutexattrValue = unsafe.Sizeof([1]C.__darwin_pthread_mutexattr_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadMutexattr) Ref() *C.__darwin_pthread_mutexattr_t {
	if x == nil {
		return nil
	}
	return x.refc7af6013
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadMutexattr) Free() {
	if x != nil && x.allocsc7af6013 != nil {
		x.allocsc7af6013.(*cgoAllocMap).Free()
		x.refc7af6013 = nil
	}
}

// New_DarwinPthreadMutexattrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadMutexattrRef(ref unsafe.Pointer) *_DarwinPthreadMutexattr {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadMutexattr)
	obj.refc7af6013 = (*C.__darwin_pthread_mutexattr_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadMutexattr) PassRef() (*C.__darwin_pthread_mutexattr_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc7af6013 != nil {
		return x.refc7af6013, nil
	}
	memc7af6013 := alloc_DarwinPthreadMutexattrMemory(1)
	refc7af6013 := (*C.__darwin_pthread_mutexattr_t)(memc7af6013)
	allocsc7af6013 := new(cgoAllocMap)
	allocsc7af6013.Add(memc7af6013)

	var c__sig_allocs *cgoAllocMap
	refc7af6013.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocsc7af6013.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	refc7af6013.__opaque, c__opaque_allocs = *(*[8]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocsc7af6013.Borrow(c__opaque_allocs)

	x.refc7af6013 = refc7af6013
	x.allocsc7af6013 = allocsc7af6013
	return refc7af6013, allocsc7af6013

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadMutexattr) PassValue() (C.__darwin_pthread_mutexattr_t, *cgoAllocMap) {
	if x.refc7af6013 != nil {
		return *x.refc7af6013, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadMutexattr) Deref() {
	if x.refc7af6013 == nil {
		return
	}
	x._Sig = (int32)(x.refc7af6013.__sig)
	x._Opaque = *(*[8]byte)(unsafe.Pointer(&x.refc7af6013.__opaque))
}

// alloc_DarwinPthreadOnceMemory allocates memory for type C.__darwin_pthread_once_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadOnceMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadOnceValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadOnceValue = unsafe.Sizeof([1]C.__darwin_pthread_once_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadOnce) Ref() *C.__darwin_pthread_once_t {
	if x == nil {
		return nil
	}
	return x.ref4689e860
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadOnce) Free() {
	if x != nil && x.allocs4689e860 != nil {
		x.allocs4689e860.(*cgoAllocMap).Free()
		x.ref4689e860 = nil
	}
}

// New_DarwinPthreadOnceRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadOnceRef(ref unsafe.Pointer) *_DarwinPthreadOnce {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadOnce)
	obj.ref4689e860 = (*C.__darwin_pthread_once_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadOnce) PassRef() (*C.__darwin_pthread_once_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4689e860 != nil {
		return x.ref4689e860, nil
	}
	mem4689e860 := alloc_DarwinPthreadOnceMemory(1)
	ref4689e860 := (*C.__darwin_pthread_once_t)(mem4689e860)
	allocs4689e860 := new(cgoAllocMap)
	allocs4689e860.Add(mem4689e860)

	var c__sig_allocs *cgoAllocMap
	ref4689e860.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocs4689e860.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	ref4689e860.__opaque, c__opaque_allocs = *(*[8]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocs4689e860.Borrow(c__opaque_allocs)

	x.ref4689e860 = ref4689e860
	x.allocs4689e860 = allocs4689e860
	return ref4689e860, allocs4689e860

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadOnce) PassValue() (C.__darwin_pthread_once_t, *cgoAllocMap) {
	if x.ref4689e860 != nil {
		return *x.ref4689e860, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadOnce) Deref() {
	if x.ref4689e860 == nil {
		return
	}
	x._Sig = (int32)(x.ref4689e860.__sig)
	x._Opaque = *(*[8]byte)(unsafe.Pointer(&x.ref4689e860.__opaque))
}

// alloc_DarwinPthreadRwlockMemory allocates memory for type C.__darwin_pthread_rwlock_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadRwlockMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadRwlockValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadRwlockValue = unsafe.Sizeof([1]C.__darwin_pthread_rwlock_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadRwlock) Ref() *C.__darwin_pthread_rwlock_t {
	if x == nil {
		return nil
	}
	return x.refe32755e2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadRwlock) Free() {
	if x != nil && x.allocse32755e2 != nil {
		x.allocse32755e2.(*cgoAllocMap).Free()
		x.refe32755e2 = nil
	}
}

// New_DarwinPthreadRwlockRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadRwlockRef(ref unsafe.Pointer) *_DarwinPthreadRwlock {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadRwlock)
	obj.refe32755e2 = (*C.__darwin_pthread_rwlock_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadRwlock) PassRef() (*C.__darwin_pthread_rwlock_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe32755e2 != nil {
		return x.refe32755e2, nil
	}
	meme32755e2 := alloc_DarwinPthreadRwlockMemory(1)
	refe32755e2 := (*C.__darwin_pthread_rwlock_t)(meme32755e2)
	allocse32755e2 := new(cgoAllocMap)
	allocse32755e2.Add(meme32755e2)

	var c__sig_allocs *cgoAllocMap
	refe32755e2.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocse32755e2.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	refe32755e2.__opaque, c__opaque_allocs = *(*[192]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocse32755e2.Borrow(c__opaque_allocs)

	x.refe32755e2 = refe32755e2
	x.allocse32755e2 = allocse32755e2
	return refe32755e2, allocse32755e2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadRwlock) PassValue() (C.__darwin_pthread_rwlock_t, *cgoAllocMap) {
	if x.refe32755e2 != nil {
		return *x.refe32755e2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadRwlock) Deref() {
	if x.refe32755e2 == nil {
		return
	}
	x._Sig = (int32)(x.refe32755e2.__sig)
	x._Opaque = *(*[192]byte)(unsafe.Pointer(&x.refe32755e2.__opaque))
}

// alloc_DarwinPthreadRwlockattrMemory allocates memory for type C.__darwin_pthread_rwlockattr_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadRwlockattrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadRwlockattrValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadRwlockattrValue = unsafe.Sizeof([1]C.__darwin_pthread_rwlockattr_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadRwlockattr) Ref() *C.__darwin_pthread_rwlockattr_t {
	if x == nil {
		return nil
	}
	return x.ref3390a2c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadRwlockattr) Free() {
	if x != nil && x.allocs3390a2c5 != nil {
		x.allocs3390a2c5.(*cgoAllocMap).Free()
		x.ref3390a2c5 = nil
	}
}

// New_DarwinPthreadRwlockattrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadRwlockattrRef(ref unsafe.Pointer) *_DarwinPthreadRwlockattr {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadRwlockattr)
	obj.ref3390a2c5 = (*C.__darwin_pthread_rwlockattr_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadRwlockattr) PassRef() (*C.__darwin_pthread_rwlockattr_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3390a2c5 != nil {
		return x.ref3390a2c5, nil
	}
	mem3390a2c5 := alloc_DarwinPthreadRwlockattrMemory(1)
	ref3390a2c5 := (*C.__darwin_pthread_rwlockattr_t)(mem3390a2c5)
	allocs3390a2c5 := new(cgoAllocMap)
	allocs3390a2c5.Add(mem3390a2c5)

	var c__sig_allocs *cgoAllocMap
	ref3390a2c5.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocs3390a2c5.Borrow(c__sig_allocs)

	var c__opaque_allocs *cgoAllocMap
	ref3390a2c5.__opaque, c__opaque_allocs = *(*[16]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocs3390a2c5.Borrow(c__opaque_allocs)

	x.ref3390a2c5 = ref3390a2c5
	x.allocs3390a2c5 = allocs3390a2c5
	return ref3390a2c5, allocs3390a2c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadRwlockattr) PassValue() (C.__darwin_pthread_rwlockattr_t, *cgoAllocMap) {
	if x.ref3390a2c5 != nil {
		return *x.ref3390a2c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadRwlockattr) Deref() {
	if x.ref3390a2c5 == nil {
		return
	}
	x._Sig = (int32)(x.ref3390a2c5.__sig)
	x._Opaque = *(*[16]byte)(unsafe.Pointer(&x.ref3390a2c5.__opaque))
}

// alloc_DarwinPthreadMemory allocates memory for type C.__darwin_pthread_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinPthreadMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinPthreadValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinPthreadValue = unsafe.Sizeof([1]C.__darwin_pthread_t{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocStruct__DarwinPthreadHandlerRecMemory allocates memory for type C.struct___darwin_pthread_handler_rec in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinPthreadHandlerRecMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinPthreadHandlerRecValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinPthreadHandlerRecValue = unsafe.Sizeof([1]C.struct___darwin_pthread_handler_rec{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackS_DarwinPthreadHandlerRec transforms a sliced Go data structure into plain C format.
func unpackS_DarwinPthreadHandlerRec(x []_DarwinPthreadHandlerRec) (unpacked *C.struct___darwin_pthread_handler_rec, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStruct__DarwinPthreadHandlerRecMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct___darwin_pthread_handler_rec)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct___darwin_pthread_handler_rec)(h.Data)
	return
}

// packS_DarwinPthreadHandlerRec reads sliced Go data structure out from plain C format.
func packS_DarwinPthreadHandlerRec(v []_DarwinPthreadHandlerRec, ptr0 *C.struct___darwin_pthread_handler_rec) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct__DarwinPthreadHandlerRecValue]C.struct___darwin_pthread_handler_rec)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *New_DarwinPthreadHandlerRecRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthread) Ref() *C.__darwin_pthread_t {
	if x == nil {
		return nil
	}
	return x.ref2cab891a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthread) Free() {
	if x != nil && x.allocs2cab891a != nil {
		x.allocs2cab891a.(*cgoAllocMap).Free()
		x.ref2cab891a = nil
	}
}

// New_DarwinPthreadRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadRef(ref unsafe.Pointer) *_DarwinPthread {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthread)
	obj.ref2cab891a = (*C.__darwin_pthread_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthread) PassRef() (*C.__darwin_pthread_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2cab891a != nil {
		return x.ref2cab891a, nil
	}
	mem2cab891a := alloc_DarwinPthreadMemory(1)
	ref2cab891a := (*C.__darwin_pthread_t)(mem2cab891a)
	allocs2cab891a := new(cgoAllocMap)
	allocs2cab891a.Add(mem2cab891a)

	var c__sig_allocs *cgoAllocMap
	ref2cab891a.__sig, c__sig_allocs = (C.long)(x._Sig), cgoAllocsUnknown
	allocs2cab891a.Borrow(c__sig_allocs)

	var c__cleanup_stack_allocs *cgoAllocMap
	ref2cab891a.__cleanup_stack, c__cleanup_stack_allocs = unpackS_DarwinPthreadHandlerRec(x._CleanupStack)
	allocs2cab891a.Borrow(c__cleanup_stack_allocs)

	var c__opaque_allocs *cgoAllocMap
	ref2cab891a.__opaque, c__opaque_allocs = *(*[8176]C.char)(unsafe.Pointer(&x._Opaque)), cgoAllocsUnknown
	allocs2cab891a.Borrow(c__opaque_allocs)

	x.ref2cab891a = ref2cab891a
	x.allocs2cab891a = allocs2cab891a
	return ref2cab891a, allocs2cab891a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthread) PassValue() (C.__darwin_pthread_t, *cgoAllocMap) {
	if x.ref2cab891a != nil {
		return *x.ref2cab891a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthread) Deref() {
	if x.ref2cab891a == nil {
		return
	}
	x._Sig = (int32)(x.ref2cab891a.__sig)
	packS_DarwinPthreadHandlerRec(x._CleanupStack, x.ref2cab891a.__cleanup_stack)
	x._Opaque = *(*[8176]byte)(unsafe.Pointer(&x.ref2cab891a.__opaque))
}

// alloc_DarwinFpControlMemory allocates memory for type C.__darwin_fp_control_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinFpControlMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinFpControlValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinFpControlValue = unsafe.Sizeof([1]C.__darwin_fp_control_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinFpControl) Ref() *C.__darwin_fp_control_t {
	if x == nil {
		return nil
	}
	return x.refc3b35bbb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinFpControl) Free() {
	if x != nil && x.allocsc3b35bbb != nil {
		x.allocsc3b35bbb.(*cgoAllocMap).Free()
		x.refc3b35bbb = nil
	}
}

// New_DarwinFpControlRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinFpControlRef(ref unsafe.Pointer) *_DarwinFpControl {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinFpControl)
	obj.refc3b35bbb = (*C.__darwin_fp_control_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinFpControl) PassRef() (*C.__darwin_fp_control_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc3b35bbb != nil {
		return x.refc3b35bbb, nil
	}
	memc3b35bbb := alloc_DarwinFpControlMemory(1)
	refc3b35bbb := (*C.__darwin_fp_control_t)(memc3b35bbb)
	allocsc3b35bbb := new(cgoAllocMap)
	allocsc3b35bbb.Add(memc3b35bbb)

	var c__invalid_allocs *cgoAllocMap
	refc3b35bbb.__invalid, c__invalid_allocs = (C.ushort)(x._Invalid), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__invalid_allocs)

	var c__denorm_allocs *cgoAllocMap
	refc3b35bbb.__denorm, c__denorm_allocs = (C.ushort)(x._Denorm), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__denorm_allocs)

	var c__zdiv_allocs *cgoAllocMap
	refc3b35bbb.__zdiv, c__zdiv_allocs = (C.ushort)(x._Zdiv), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__zdiv_allocs)

	var c__ovrfl_allocs *cgoAllocMap
	refc3b35bbb.__ovrfl, c__ovrfl_allocs = (C.ushort)(x._Ovrfl), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__ovrfl_allocs)

	var c__undfl_allocs *cgoAllocMap
	refc3b35bbb.__undfl, c__undfl_allocs = (C.ushort)(x._Undfl), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__undfl_allocs)

	var c__precis_allocs *cgoAllocMap
	refc3b35bbb.__precis, c__precis_allocs = (C.ushort)(x._Precis), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__precis_allocs)

	var cfield6_allocs *cgoAllocMap
	refc3b35bbb.field6, cfield6_allocs = (C.int)(x.Field6), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(cfield6_allocs)

	var c__pc_allocs *cgoAllocMap
	refc3b35bbb.__pc, c__pc_allocs = (C.ushort)(x._Pc), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__pc_allocs)

	var c__rc_allocs *cgoAllocMap
	refc3b35bbb.__rc, c__rc_allocs = (C.ushort)(x._Rc), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(c__rc_allocs)

	var cfield9_allocs *cgoAllocMap
	refc3b35bbb.field9, cfield9_allocs = (C.int)(x.Field9), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(cfield9_allocs)

	var cfield10_allocs *cgoAllocMap
	refc3b35bbb.field10, cfield10_allocs = (C.int)(x.Field10), cgoAllocsUnknown
	allocsc3b35bbb.Borrow(cfield10_allocs)

	x.refc3b35bbb = refc3b35bbb
	x.allocsc3b35bbb = allocsc3b35bbb
	return refc3b35bbb, allocsc3b35bbb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinFpControl) PassValue() (C.__darwin_fp_control_t, *cgoAllocMap) {
	if x.refc3b35bbb != nil {
		return *x.refc3b35bbb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinFpControl) Deref() {
	if x.refc3b35bbb == nil {
		return
	}
	x._Invalid = (uint16)(x.refc3b35bbb.__invalid)
	x._Denorm = (uint16)(x.refc3b35bbb.__denorm)
	x._Zdiv = (uint16)(x.refc3b35bbb.__zdiv)
	x._Ovrfl = (uint16)(x.refc3b35bbb.__ovrfl)
	x._Undfl = (uint16)(x.refc3b35bbb.__undfl)
	x._Precis = (uint16)(x.refc3b35bbb.__precis)
	x.Field6 = (int32)(x.refc3b35bbb.field6)
	x._Pc = (uint16)(x.refc3b35bbb.__pc)
	x._Rc = (uint16)(x.refc3b35bbb.__rc)
	x.Field9 = (int32)(x.refc3b35bbb.field9)
	x.Field10 = (int32)(x.refc3b35bbb.field10)
}

// alloc_DarwinFpStatusMemory allocates memory for type C.__darwin_fp_status_t in C.
// The caller is responsible for freeing the this memory via C.free.
func alloc_DarwinFpStatusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOf_DarwinFpStatusValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOf_DarwinFpStatusValue = unsafe.Sizeof([1]C.__darwin_fp_status_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinFpStatus) Ref() *C.__darwin_fp_status_t {
	if x == nil {
		return nil
	}
	return x.ref88b7dfb8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinFpStatus) Free() {
	if x != nil && x.allocs88b7dfb8 != nil {
		x.allocs88b7dfb8.(*cgoAllocMap).Free()
		x.ref88b7dfb8 = nil
	}
}

// New_DarwinFpStatusRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinFpStatusRef(ref unsafe.Pointer) *_DarwinFpStatus {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinFpStatus)
	obj.ref88b7dfb8 = (*C.__darwin_fp_status_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinFpStatus) PassRef() (*C.__darwin_fp_status_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref88b7dfb8 != nil {
		return x.ref88b7dfb8, nil
	}
	mem88b7dfb8 := alloc_DarwinFpStatusMemory(1)
	ref88b7dfb8 := (*C.__darwin_fp_status_t)(mem88b7dfb8)
	allocs88b7dfb8 := new(cgoAllocMap)
	allocs88b7dfb8.Add(mem88b7dfb8)

	var c__invalid_allocs *cgoAllocMap
	ref88b7dfb8.__invalid, c__invalid_allocs = (C.ushort)(x._Invalid), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__invalid_allocs)

	var c__denorm_allocs *cgoAllocMap
	ref88b7dfb8.__denorm, c__denorm_allocs = (C.ushort)(x._Denorm), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__denorm_allocs)

	var c__zdiv_allocs *cgoAllocMap
	ref88b7dfb8.__zdiv, c__zdiv_allocs = (C.ushort)(x._Zdiv), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__zdiv_allocs)

	var c__ovrfl_allocs *cgoAllocMap
	ref88b7dfb8.__ovrfl, c__ovrfl_allocs = (C.ushort)(x._Ovrfl), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__ovrfl_allocs)

	var c__undfl_allocs *cgoAllocMap
	ref88b7dfb8.__undfl, c__undfl_allocs = (C.ushort)(x._Undfl), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__undfl_allocs)

	var c__precis_allocs *cgoAllocMap
	ref88b7dfb8.__precis, c__precis_allocs = (C.ushort)(x._Precis), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__precis_allocs)

	var c__stkflt_allocs *cgoAllocMap
	ref88b7dfb8.__stkflt, c__stkflt_allocs = (C.ushort)(x._Stkflt), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__stkflt_allocs)

	var c__errsumm_allocs *cgoAllocMap
	ref88b7dfb8.__errsumm, c__errsumm_allocs = (C.ushort)(x._Errsumm), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__errsumm_allocs)

	var c__c0_allocs *cgoAllocMap
	ref88b7dfb8.__c0, c__c0_allocs = (C.ushort)(x._C0), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__c0_allocs)

	var c__c1_allocs *cgoAllocMap
	ref88b7dfb8.__c1, c__c1_allocs = (C.ushort)(x._C1), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__c1_allocs)

	var c__c2_allocs *cgoAllocMap
	ref88b7dfb8.__c2, c__c2_allocs = (C.ushort)(x._C2), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__c2_allocs)

	var c__tos_allocs *cgoAllocMap
	ref88b7dfb8.__tos, c__tos_allocs = (C.ushort)(x._Tos), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__tos_allocs)

	var c__c3_allocs *cgoAllocMap
	ref88b7dfb8.__c3, c__c3_allocs = (C.ushort)(x._C3), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__c3_allocs)

	var c__busy_allocs *cgoAllocMap
	ref88b7dfb8.__busy, c__busy_allocs = (C.ushort)(x._Busy), cgoAllocsUnknown
	allocs88b7dfb8.Borrow(c__busy_allocs)

	x.ref88b7dfb8 = ref88b7dfb8
	x.allocs88b7dfb8 = allocs88b7dfb8
	return ref88b7dfb8, allocs88b7dfb8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinFpStatus) PassValue() (C.__darwin_fp_status_t, *cgoAllocMap) {
	if x.ref88b7dfb8 != nil {
		return *x.ref88b7dfb8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinFpStatus) Deref() {
	if x.ref88b7dfb8 == nil {
		return
	}
	x._Invalid = (uint16)(x.ref88b7dfb8.__invalid)
	x._Denorm = (uint16)(x.ref88b7dfb8.__denorm)
	x._Zdiv = (uint16)(x.ref88b7dfb8.__zdiv)
	x._Ovrfl = (uint16)(x.ref88b7dfb8.__ovrfl)
	x._Undfl = (uint16)(x.ref88b7dfb8.__undfl)
	x._Precis = (uint16)(x.ref88b7dfb8.__precis)
	x._Stkflt = (uint16)(x.ref88b7dfb8.__stkflt)
	x._Errsumm = (uint16)(x.ref88b7dfb8.__errsumm)
	x._C0 = (uint16)(x.ref88b7dfb8.__c0)
	x._C1 = (uint16)(x.ref88b7dfb8.__c1)
	x._C2 = (uint16)(x.ref88b7dfb8.__c2)
	x._Tos = (uint16)(x.ref88b7dfb8.__tos)
	x._C3 = (uint16)(x.ref88b7dfb8.__c3)
	x._Busy = (uint16)(x.ref88b7dfb8.__busy)
}

// allocStruct__DarwinI386Avx512StateMemory allocates memory for type C.struct___darwin_i386_avx512_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinI386Avx512StateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinI386Avx512StateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinI386Avx512StateValue = unsafe.Sizeof([1]C.struct___darwin_i386_avx512_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinI386Avx512State) Ref() *C.struct___darwin_i386_avx512_state {
	if x == nil {
		return nil
	}
	return x.ref5db8cb9e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinI386Avx512State) Free() {
	if x != nil && x.allocs5db8cb9e != nil {
		x.allocs5db8cb9e.(*cgoAllocMap).Free()
		x.ref5db8cb9e = nil
	}
}

// New_DarwinI386Avx512StateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinI386Avx512StateRef(ref unsafe.Pointer) *_DarwinI386Avx512State {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinI386Avx512State)
	obj.ref5db8cb9e = (*C.struct___darwin_i386_avx512_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinI386Avx512State) PassRef() (*C.struct___darwin_i386_avx512_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5db8cb9e != nil {
		return x.ref5db8cb9e, nil
	}
	mem5db8cb9e := allocStruct__DarwinI386Avx512StateMemory(1)
	ref5db8cb9e := (*C.struct___darwin_i386_avx512_state)(mem5db8cb9e)
	allocs5db8cb9e := new(cgoAllocMap)
	allocs5db8cb9e.Add(mem5db8cb9e)

	var c__fpu_reserved_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_reserved, c__fpu_reserved_allocs = *(*[2]C.int)(unsafe.Pointer(&x._FpuReserved)), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_reserved_allocs)

	var c__fpu_fcw_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_fcw, c__fpu_fcw_allocs = x._FpuFcw.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_fcw_allocs)

	var c__fpu_fsw_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_fsw, c__fpu_fsw_allocs = x._FpuFsw.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_fsw_allocs)

	var c__fpu_ftw_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ftw, c__fpu_ftw_allocs = (C.__uint8_t)(x._FpuFtw), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_ftw_allocs)

	var c__fpu_rsrv1_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_rsrv1, c__fpu_rsrv1_allocs = (C.__uint8_t)(x._FpuRsrv1), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_rsrv1_allocs)

	var c__fpu_fop_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_fop, c__fpu_fop_allocs = (C.__uint16_t)(x._FpuFop), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_fop_allocs)

	var c__fpu_ip_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ip, c__fpu_ip_allocs = (C.__uint32_t)(x._FpuIp), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_ip_allocs)

	var c__fpu_cs_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_cs, c__fpu_cs_allocs = (C.__uint16_t)(x._FpuCs), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_cs_allocs)

	var c__fpu_rsrv2_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_rsrv2, c__fpu_rsrv2_allocs = (C.__uint16_t)(x._FpuRsrv2), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_rsrv2_allocs)

	var c__fpu_dp_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_dp, c__fpu_dp_allocs = (C.__uint32_t)(x._FpuDp), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_dp_allocs)

	var c__fpu_ds_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ds, c__fpu_ds_allocs = (C.__uint16_t)(x._FpuDs), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_ds_allocs)

	var c__fpu_rsrv3_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_rsrv3, c__fpu_rsrv3_allocs = (C.__uint16_t)(x._FpuRsrv3), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_rsrv3_allocs)

	var c__fpu_mxcsr_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_mxcsr, c__fpu_mxcsr_allocs = (C.__uint32_t)(x._FpuMxcsr), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_mxcsr_allocs)

	var c__fpu_mxcsrmask_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_mxcsrmask, c__fpu_mxcsrmask_allocs = (C.__uint32_t)(x._FpuMxcsrmask), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_mxcsrmask_allocs)

	var c__fpu_stmm0_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm0, c__fpu_stmm0_allocs = x._FpuStmm0.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm0_allocs)

	var c__fpu_stmm1_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm1, c__fpu_stmm1_allocs = x._FpuStmm1.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm1_allocs)

	var c__fpu_stmm2_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm2, c__fpu_stmm2_allocs = x._FpuStmm2.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm2_allocs)

	var c__fpu_stmm3_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm3, c__fpu_stmm3_allocs = x._FpuStmm3.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm3_allocs)

	var c__fpu_stmm4_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm4, c__fpu_stmm4_allocs = x._FpuStmm4.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm4_allocs)

	var c__fpu_stmm5_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm5, c__fpu_stmm5_allocs = x._FpuStmm5.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm5_allocs)

	var c__fpu_stmm6_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm6, c__fpu_stmm6_allocs = x._FpuStmm6.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm6_allocs)

	var c__fpu_stmm7_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_stmm7, c__fpu_stmm7_allocs = x._FpuStmm7.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_stmm7_allocs)

	var c__fpu_xmm0_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm0, c__fpu_xmm0_allocs = x._FpuXmm0.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm0_allocs)

	var c__fpu_xmm1_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm1, c__fpu_xmm1_allocs = x._FpuXmm1.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm1_allocs)

	var c__fpu_xmm2_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm2, c__fpu_xmm2_allocs = x._FpuXmm2.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm2_allocs)

	var c__fpu_xmm3_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm3, c__fpu_xmm3_allocs = x._FpuXmm3.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm3_allocs)

	var c__fpu_xmm4_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm4, c__fpu_xmm4_allocs = x._FpuXmm4.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm4_allocs)

	var c__fpu_xmm5_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm5, c__fpu_xmm5_allocs = x._FpuXmm5.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm5_allocs)

	var c__fpu_xmm6_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm6, c__fpu_xmm6_allocs = x._FpuXmm6.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm6_allocs)

	var c__fpu_xmm7_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_xmm7, c__fpu_xmm7_allocs = x._FpuXmm7.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_xmm7_allocs)

	var c__fpu_rsrv4_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_rsrv4, c__fpu_rsrv4_allocs = *(*[224]C.char)(unsafe.Pointer(&x._FpuRsrv4)), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_rsrv4_allocs)

	var c__fpu_reserved1_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_reserved1, c__fpu_reserved1_allocs = (C.int)(x._FpuReserved1), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__fpu_reserved1_allocs)

	var c__avx_reserved1_allocs *cgoAllocMap
	ref5db8cb9e.__avx_reserved1, c__avx_reserved1_allocs = *(*[64]C.char)(unsafe.Pointer(&x._AvxReserved1)), cgoAllocsUnknown
	allocs5db8cb9e.Borrow(c__avx_reserved1_allocs)

	var c__fpu_ymmh0_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh0, c__fpu_ymmh0_allocs = x._FpuYmmh0.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh0_allocs)

	var c__fpu_ymmh1_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh1, c__fpu_ymmh1_allocs = x._FpuYmmh1.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh1_allocs)

	var c__fpu_ymmh2_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh2, c__fpu_ymmh2_allocs = x._FpuYmmh2.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh2_allocs)

	var c__fpu_ymmh3_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh3, c__fpu_ymmh3_allocs = x._FpuYmmh3.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh3_allocs)

	var c__fpu_ymmh4_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh4, c__fpu_ymmh4_allocs = x._FpuYmmh4.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh4_allocs)

	var c__fpu_ymmh5_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh5, c__fpu_ymmh5_allocs = x._FpuYmmh5.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh5_allocs)

	var c__fpu_ymmh6_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh6, c__fpu_ymmh6_allocs = x._FpuYmmh6.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh6_allocs)

	var c__fpu_ymmh7_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_ymmh7, c__fpu_ymmh7_allocs = x._FpuYmmh7.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_ymmh7_allocs)

	var c__fpu_k0_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k0, c__fpu_k0_allocs = x._FpuK0.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k0_allocs)

	var c__fpu_k1_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k1, c__fpu_k1_allocs = x._FpuK1.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k1_allocs)

	var c__fpu_k2_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k2, c__fpu_k2_allocs = x._FpuK2.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k2_allocs)

	var c__fpu_k3_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k3, c__fpu_k3_allocs = x._FpuK3.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k3_allocs)

	var c__fpu_k4_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k4, c__fpu_k4_allocs = x._FpuK4.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k4_allocs)

	var c__fpu_k5_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k5, c__fpu_k5_allocs = x._FpuK5.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k5_allocs)

	var c__fpu_k6_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k6, c__fpu_k6_allocs = x._FpuK6.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k6_allocs)

	var c__fpu_k7_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_k7, c__fpu_k7_allocs = x._FpuK7.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_k7_allocs)

	var c__fpu_zmmh0_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh0, c__fpu_zmmh0_allocs = x._FpuZmmh0.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh0_allocs)

	var c__fpu_zmmh1_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh1, c__fpu_zmmh1_allocs = x._FpuZmmh1.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh1_allocs)

	var c__fpu_zmmh2_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh2, c__fpu_zmmh2_allocs = x._FpuZmmh2.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh2_allocs)

	var c__fpu_zmmh3_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh3, c__fpu_zmmh3_allocs = x._FpuZmmh3.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh3_allocs)

	var c__fpu_zmmh4_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh4, c__fpu_zmmh4_allocs = x._FpuZmmh4.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh4_allocs)

	var c__fpu_zmmh5_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh5, c__fpu_zmmh5_allocs = x._FpuZmmh5.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh5_allocs)

	var c__fpu_zmmh6_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh6, c__fpu_zmmh6_allocs = x._FpuZmmh6.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh6_allocs)

	var c__fpu_zmmh7_allocs *cgoAllocMap
	ref5db8cb9e.__fpu_zmmh7, c__fpu_zmmh7_allocs = x._FpuZmmh7.PassValue()
	allocs5db8cb9e.Borrow(c__fpu_zmmh7_allocs)

	x.ref5db8cb9e = ref5db8cb9e
	x.allocs5db8cb9e = allocs5db8cb9e
	return ref5db8cb9e, allocs5db8cb9e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinI386Avx512State) PassValue() (C.struct___darwin_i386_avx512_state, *cgoAllocMap) {
	if x.ref5db8cb9e != nil {
		return *x.ref5db8cb9e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinI386Avx512State) Deref() {
	if x.ref5db8cb9e == nil {
		return
	}
	x._FpuReserved = *(*[2]int32)(unsafe.Pointer(&x.ref5db8cb9e.__fpu_reserved))
	x._FpuFcw = *New_DarwinFpControlRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_fcw))
	x._FpuFsw = *New_DarwinFpStatusRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_fsw))
	x._FpuFtw = (byte)(x.ref5db8cb9e.__fpu_ftw)
	x._FpuRsrv1 = (byte)(x.ref5db8cb9e.__fpu_rsrv1)
	x._FpuFop = (uint16)(x.ref5db8cb9e.__fpu_fop)
	x._FpuIp = (uint32)(x.ref5db8cb9e.__fpu_ip)
	x._FpuCs = (uint16)(x.ref5db8cb9e.__fpu_cs)
	x._FpuRsrv2 = (uint16)(x.ref5db8cb9e.__fpu_rsrv2)
	x._FpuDp = (uint32)(x.ref5db8cb9e.__fpu_dp)
	x._FpuDs = (uint16)(x.ref5db8cb9e.__fpu_ds)
	x._FpuRsrv3 = (uint16)(x.ref5db8cb9e.__fpu_rsrv3)
	x._FpuMxcsr = (uint32)(x.ref5db8cb9e.__fpu_mxcsr)
	x._FpuMxcsrmask = (uint32)(x.ref5db8cb9e.__fpu_mxcsrmask)
	x._FpuStmm0 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm0))
	x._FpuStmm1 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm1))
	x._FpuStmm2 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm2))
	x._FpuStmm3 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm3))
	x._FpuStmm4 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm4))
	x._FpuStmm5 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm5))
	x._FpuStmm6 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm6))
	x._FpuStmm7 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_stmm7))
	x._FpuXmm0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm0))
	x._FpuXmm1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm1))
	x._FpuXmm2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm2))
	x._FpuXmm3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm3))
	x._FpuXmm4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm4))
	x._FpuXmm5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm5))
	x._FpuXmm6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm6))
	x._FpuXmm7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_xmm7))
	x._FpuRsrv4 = *(*[224]byte)(unsafe.Pointer(&x.ref5db8cb9e.__fpu_rsrv4))
	x._FpuReserved1 = (int32)(x.ref5db8cb9e.__fpu_reserved1)
	x._AvxReserved1 = *(*[64]byte)(unsafe.Pointer(&x.ref5db8cb9e.__avx_reserved1))
	x._FpuYmmh0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh0))
	x._FpuYmmh1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh1))
	x._FpuYmmh2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh2))
	x._FpuYmmh3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh3))
	x._FpuYmmh4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh4))
	x._FpuYmmh5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh5))
	x._FpuYmmh6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh6))
	x._FpuYmmh7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_ymmh7))
	x._FpuK0 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k0))
	x._FpuK1 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k1))
	x._FpuK2 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k2))
	x._FpuK3 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k3))
	x._FpuK4 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k4))
	x._FpuK5 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k5))
	x._FpuK6 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k6))
	x._FpuK7 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_k7))
	x._FpuZmmh0 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh0))
	x._FpuZmmh1 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh1))
	x._FpuZmmh2 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh2))
	x._FpuZmmh3 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh3))
	x._FpuZmmh4 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh4))
	x._FpuZmmh5 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh5))
	x._FpuZmmh6 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh6))
	x._FpuZmmh7 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.ref5db8cb9e.__fpu_zmmh7))
}

// allocStruct__DarwinI386AvxStateMemory allocates memory for type C.struct___darwin_i386_avx_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinI386AvxStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinI386AvxStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinI386AvxStateValue = unsafe.Sizeof([1]C.struct___darwin_i386_avx_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinI386AvxState) Ref() *C.struct___darwin_i386_avx_state {
	if x == nil {
		return nil
	}
	return x.ref3806343e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinI386AvxState) Free() {
	if x != nil && x.allocs3806343e != nil {
		x.allocs3806343e.(*cgoAllocMap).Free()
		x.ref3806343e = nil
	}
}

// New_DarwinI386AvxStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinI386AvxStateRef(ref unsafe.Pointer) *_DarwinI386AvxState {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinI386AvxState)
	obj.ref3806343e = (*C.struct___darwin_i386_avx_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinI386AvxState) PassRef() (*C.struct___darwin_i386_avx_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3806343e != nil {
		return x.ref3806343e, nil
	}
	mem3806343e := allocStruct__DarwinI386AvxStateMemory(1)
	ref3806343e := (*C.struct___darwin_i386_avx_state)(mem3806343e)
	allocs3806343e := new(cgoAllocMap)
	allocs3806343e.Add(mem3806343e)

	var c__fpu_reserved_allocs *cgoAllocMap
	ref3806343e.__fpu_reserved, c__fpu_reserved_allocs = *(*[2]C.int)(unsafe.Pointer(&x._FpuReserved)), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_reserved_allocs)

	var c__fpu_fcw_allocs *cgoAllocMap
	ref3806343e.__fpu_fcw, c__fpu_fcw_allocs = x._FpuFcw.PassValue()
	allocs3806343e.Borrow(c__fpu_fcw_allocs)

	var c__fpu_fsw_allocs *cgoAllocMap
	ref3806343e.__fpu_fsw, c__fpu_fsw_allocs = x._FpuFsw.PassValue()
	allocs3806343e.Borrow(c__fpu_fsw_allocs)

	var c__fpu_ftw_allocs *cgoAllocMap
	ref3806343e.__fpu_ftw, c__fpu_ftw_allocs = (C.__uint8_t)(x._FpuFtw), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_ftw_allocs)

	var c__fpu_rsrv1_allocs *cgoAllocMap
	ref3806343e.__fpu_rsrv1, c__fpu_rsrv1_allocs = (C.__uint8_t)(x._FpuRsrv1), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_rsrv1_allocs)

	var c__fpu_fop_allocs *cgoAllocMap
	ref3806343e.__fpu_fop, c__fpu_fop_allocs = (C.__uint16_t)(x._FpuFop), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_fop_allocs)

	var c__fpu_ip_allocs *cgoAllocMap
	ref3806343e.__fpu_ip, c__fpu_ip_allocs = (C.__uint32_t)(x._FpuIp), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_ip_allocs)

	var c__fpu_cs_allocs *cgoAllocMap
	ref3806343e.__fpu_cs, c__fpu_cs_allocs = (C.__uint16_t)(x._FpuCs), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_cs_allocs)

	var c__fpu_rsrv2_allocs *cgoAllocMap
	ref3806343e.__fpu_rsrv2, c__fpu_rsrv2_allocs = (C.__uint16_t)(x._FpuRsrv2), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_rsrv2_allocs)

	var c__fpu_dp_allocs *cgoAllocMap
	ref3806343e.__fpu_dp, c__fpu_dp_allocs = (C.__uint32_t)(x._FpuDp), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_dp_allocs)

	var c__fpu_ds_allocs *cgoAllocMap
	ref3806343e.__fpu_ds, c__fpu_ds_allocs = (C.__uint16_t)(x._FpuDs), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_ds_allocs)

	var c__fpu_rsrv3_allocs *cgoAllocMap
	ref3806343e.__fpu_rsrv3, c__fpu_rsrv3_allocs = (C.__uint16_t)(x._FpuRsrv3), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_rsrv3_allocs)

	var c__fpu_mxcsr_allocs *cgoAllocMap
	ref3806343e.__fpu_mxcsr, c__fpu_mxcsr_allocs = (C.__uint32_t)(x._FpuMxcsr), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_mxcsr_allocs)

	var c__fpu_mxcsrmask_allocs *cgoAllocMap
	ref3806343e.__fpu_mxcsrmask, c__fpu_mxcsrmask_allocs = (C.__uint32_t)(x._FpuMxcsrmask), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_mxcsrmask_allocs)

	var c__fpu_stmm0_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm0, c__fpu_stmm0_allocs = x._FpuStmm0.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm0_allocs)

	var c__fpu_stmm1_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm1, c__fpu_stmm1_allocs = x._FpuStmm1.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm1_allocs)

	var c__fpu_stmm2_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm2, c__fpu_stmm2_allocs = x._FpuStmm2.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm2_allocs)

	var c__fpu_stmm3_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm3, c__fpu_stmm3_allocs = x._FpuStmm3.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm3_allocs)

	var c__fpu_stmm4_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm4, c__fpu_stmm4_allocs = x._FpuStmm4.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm4_allocs)

	var c__fpu_stmm5_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm5, c__fpu_stmm5_allocs = x._FpuStmm5.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm5_allocs)

	var c__fpu_stmm6_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm6, c__fpu_stmm6_allocs = x._FpuStmm6.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm6_allocs)

	var c__fpu_stmm7_allocs *cgoAllocMap
	ref3806343e.__fpu_stmm7, c__fpu_stmm7_allocs = x._FpuStmm7.PassValue()
	allocs3806343e.Borrow(c__fpu_stmm7_allocs)

	var c__fpu_xmm0_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm0, c__fpu_xmm0_allocs = x._FpuXmm0.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm0_allocs)

	var c__fpu_xmm1_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm1, c__fpu_xmm1_allocs = x._FpuXmm1.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm1_allocs)

	var c__fpu_xmm2_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm2, c__fpu_xmm2_allocs = x._FpuXmm2.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm2_allocs)

	var c__fpu_xmm3_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm3, c__fpu_xmm3_allocs = x._FpuXmm3.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm3_allocs)

	var c__fpu_xmm4_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm4, c__fpu_xmm4_allocs = x._FpuXmm4.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm4_allocs)

	var c__fpu_xmm5_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm5, c__fpu_xmm5_allocs = x._FpuXmm5.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm5_allocs)

	var c__fpu_xmm6_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm6, c__fpu_xmm6_allocs = x._FpuXmm6.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm6_allocs)

	var c__fpu_xmm7_allocs *cgoAllocMap
	ref3806343e.__fpu_xmm7, c__fpu_xmm7_allocs = x._FpuXmm7.PassValue()
	allocs3806343e.Borrow(c__fpu_xmm7_allocs)

	var c__fpu_rsrv4_allocs *cgoAllocMap
	ref3806343e.__fpu_rsrv4, c__fpu_rsrv4_allocs = *(*[224]C.char)(unsafe.Pointer(&x._FpuRsrv4)), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_rsrv4_allocs)

	var c__fpu_reserved1_allocs *cgoAllocMap
	ref3806343e.__fpu_reserved1, c__fpu_reserved1_allocs = (C.int)(x._FpuReserved1), cgoAllocsUnknown
	allocs3806343e.Borrow(c__fpu_reserved1_allocs)

	var c__avx_reserved1_allocs *cgoAllocMap
	ref3806343e.__avx_reserved1, c__avx_reserved1_allocs = *(*[64]C.char)(unsafe.Pointer(&x._AvxReserved1)), cgoAllocsUnknown
	allocs3806343e.Borrow(c__avx_reserved1_allocs)

	var c__fpu_ymmh0_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh0, c__fpu_ymmh0_allocs = x._FpuYmmh0.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh0_allocs)

	var c__fpu_ymmh1_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh1, c__fpu_ymmh1_allocs = x._FpuYmmh1.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh1_allocs)

	var c__fpu_ymmh2_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh2, c__fpu_ymmh2_allocs = x._FpuYmmh2.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh2_allocs)

	var c__fpu_ymmh3_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh3, c__fpu_ymmh3_allocs = x._FpuYmmh3.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh3_allocs)

	var c__fpu_ymmh4_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh4, c__fpu_ymmh4_allocs = x._FpuYmmh4.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh4_allocs)

	var c__fpu_ymmh5_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh5, c__fpu_ymmh5_allocs = x._FpuYmmh5.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh5_allocs)

	var c__fpu_ymmh6_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh6, c__fpu_ymmh6_allocs = x._FpuYmmh6.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh6_allocs)

	var c__fpu_ymmh7_allocs *cgoAllocMap
	ref3806343e.__fpu_ymmh7, c__fpu_ymmh7_allocs = x._FpuYmmh7.PassValue()
	allocs3806343e.Borrow(c__fpu_ymmh7_allocs)

	x.ref3806343e = ref3806343e
	x.allocs3806343e = allocs3806343e
	return ref3806343e, allocs3806343e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinI386AvxState) PassValue() (C.struct___darwin_i386_avx_state, *cgoAllocMap) {
	if x.ref3806343e != nil {
		return *x.ref3806343e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinI386AvxState) Deref() {
	if x.ref3806343e == nil {
		return
	}
	x._FpuReserved = *(*[2]int32)(unsafe.Pointer(&x.ref3806343e.__fpu_reserved))
	x._FpuFcw = *New_DarwinFpControlRef(unsafe.Pointer(&x.ref3806343e.__fpu_fcw))
	x._FpuFsw = *New_DarwinFpStatusRef(unsafe.Pointer(&x.ref3806343e.__fpu_fsw))
	x._FpuFtw = (byte)(x.ref3806343e.__fpu_ftw)
	x._FpuRsrv1 = (byte)(x.ref3806343e.__fpu_rsrv1)
	x._FpuFop = (uint16)(x.ref3806343e.__fpu_fop)
	x._FpuIp = (uint32)(x.ref3806343e.__fpu_ip)
	x._FpuCs = (uint16)(x.ref3806343e.__fpu_cs)
	x._FpuRsrv2 = (uint16)(x.ref3806343e.__fpu_rsrv2)
	x._FpuDp = (uint32)(x.ref3806343e.__fpu_dp)
	x._FpuDs = (uint16)(x.ref3806343e.__fpu_ds)
	x._FpuRsrv3 = (uint16)(x.ref3806343e.__fpu_rsrv3)
	x._FpuMxcsr = (uint32)(x.ref3806343e.__fpu_mxcsr)
	x._FpuMxcsrmask = (uint32)(x.ref3806343e.__fpu_mxcsrmask)
	x._FpuStmm0 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm0))
	x._FpuStmm1 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm1))
	x._FpuStmm2 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm2))
	x._FpuStmm3 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm3))
	x._FpuStmm4 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm4))
	x._FpuStmm5 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm5))
	x._FpuStmm6 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm6))
	x._FpuStmm7 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_stmm7))
	x._FpuXmm0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm0))
	x._FpuXmm1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm1))
	x._FpuXmm2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm2))
	x._FpuXmm3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm3))
	x._FpuXmm4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm4))
	x._FpuXmm5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm5))
	x._FpuXmm6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm6))
	x._FpuXmm7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_xmm7))
	x._FpuRsrv4 = *(*[224]byte)(unsafe.Pointer(&x.ref3806343e.__fpu_rsrv4))
	x._FpuReserved1 = (int32)(x.ref3806343e.__fpu_reserved1)
	x._AvxReserved1 = *(*[64]byte)(unsafe.Pointer(&x.ref3806343e.__avx_reserved1))
	x._FpuYmmh0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh0))
	x._FpuYmmh1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh1))
	x._FpuYmmh2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh2))
	x._FpuYmmh3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh3))
	x._FpuYmmh4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh4))
	x._FpuYmmh5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh5))
	x._FpuYmmh6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh6))
	x._FpuYmmh7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref3806343e.__fpu_ymmh7))
}

// allocStruct__DarwinI386ExceptionStateMemory allocates memory for type C.struct___darwin_i386_exception_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinI386ExceptionStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinI386ExceptionStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinI386ExceptionStateValue = unsafe.Sizeof([1]C.struct___darwin_i386_exception_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinI386ExceptionState) Ref() *C.struct___darwin_i386_exception_state {
	if x == nil {
		return nil
	}
	return x.refa1b2e769
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinI386ExceptionState) Free() {
	if x != nil && x.allocsa1b2e769 != nil {
		x.allocsa1b2e769.(*cgoAllocMap).Free()
		x.refa1b2e769 = nil
	}
}

// New_DarwinI386ExceptionStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinI386ExceptionStateRef(ref unsafe.Pointer) *_DarwinI386ExceptionState {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinI386ExceptionState)
	obj.refa1b2e769 = (*C.struct___darwin_i386_exception_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinI386ExceptionState) PassRef() (*C.struct___darwin_i386_exception_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa1b2e769 != nil {
		return x.refa1b2e769, nil
	}
	mema1b2e769 := allocStruct__DarwinI386ExceptionStateMemory(1)
	refa1b2e769 := (*C.struct___darwin_i386_exception_state)(mema1b2e769)
	allocsa1b2e769 := new(cgoAllocMap)
	allocsa1b2e769.Add(mema1b2e769)

	var c__trapno_allocs *cgoAllocMap
	refa1b2e769.__trapno, c__trapno_allocs = (C.__uint16_t)(x._Trapno), cgoAllocsUnknown
	allocsa1b2e769.Borrow(c__trapno_allocs)

	var c__cpu_allocs *cgoAllocMap
	refa1b2e769.__cpu, c__cpu_allocs = (C.__uint16_t)(x._Cpu), cgoAllocsUnknown
	allocsa1b2e769.Borrow(c__cpu_allocs)

	var c__err_allocs *cgoAllocMap
	refa1b2e769.__err, c__err_allocs = (C.__uint32_t)(x._Err), cgoAllocsUnknown
	allocsa1b2e769.Borrow(c__err_allocs)

	var c__faultvaddr_allocs *cgoAllocMap
	refa1b2e769.__faultvaddr, c__faultvaddr_allocs = (C.__uint32_t)(x._Faultvaddr), cgoAllocsUnknown
	allocsa1b2e769.Borrow(c__faultvaddr_allocs)

	x.refa1b2e769 = refa1b2e769
	x.allocsa1b2e769 = allocsa1b2e769
	return refa1b2e769, allocsa1b2e769

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinI386ExceptionState) PassValue() (C.struct___darwin_i386_exception_state, *cgoAllocMap) {
	if x.refa1b2e769 != nil {
		return *x.refa1b2e769, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinI386ExceptionState) Deref() {
	if x.refa1b2e769 == nil {
		return
	}
	x._Trapno = (uint16)(x.refa1b2e769.__trapno)
	x._Cpu = (uint16)(x.refa1b2e769.__cpu)
	x._Err = (uint32)(x.refa1b2e769.__err)
	x._Faultvaddr = (uint32)(x.refa1b2e769.__faultvaddr)
}

// allocStruct__DarwinI386FloatStateMemory allocates memory for type C.struct___darwin_i386_float_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinI386FloatStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinI386FloatStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinI386FloatStateValue = unsafe.Sizeof([1]C.struct___darwin_i386_float_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinI386FloatState) Ref() *C.struct___darwin_i386_float_state {
	if x == nil {
		return nil
	}
	return x.refa3972104
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinI386FloatState) Free() {
	if x != nil && x.allocsa3972104 != nil {
		x.allocsa3972104.(*cgoAllocMap).Free()
		x.refa3972104 = nil
	}
}

// New_DarwinI386FloatStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinI386FloatStateRef(ref unsafe.Pointer) *_DarwinI386FloatState {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinI386FloatState)
	obj.refa3972104 = (*C.struct___darwin_i386_float_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinI386FloatState) PassRef() (*C.struct___darwin_i386_float_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa3972104 != nil {
		return x.refa3972104, nil
	}
	mema3972104 := allocStruct__DarwinI386FloatStateMemory(1)
	refa3972104 := (*C.struct___darwin_i386_float_state)(mema3972104)
	allocsa3972104 := new(cgoAllocMap)
	allocsa3972104.Add(mema3972104)

	var c__fpu_reserved_allocs *cgoAllocMap
	refa3972104.__fpu_reserved, c__fpu_reserved_allocs = *(*[2]C.int)(unsafe.Pointer(&x._FpuReserved)), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_reserved_allocs)

	var c__fpu_fcw_allocs *cgoAllocMap
	refa3972104.__fpu_fcw, c__fpu_fcw_allocs = x._FpuFcw.PassValue()
	allocsa3972104.Borrow(c__fpu_fcw_allocs)

	var c__fpu_fsw_allocs *cgoAllocMap
	refa3972104.__fpu_fsw, c__fpu_fsw_allocs = x._FpuFsw.PassValue()
	allocsa3972104.Borrow(c__fpu_fsw_allocs)

	var c__fpu_ftw_allocs *cgoAllocMap
	refa3972104.__fpu_ftw, c__fpu_ftw_allocs = (C.__uint8_t)(x._FpuFtw), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_ftw_allocs)

	var c__fpu_rsrv1_allocs *cgoAllocMap
	refa3972104.__fpu_rsrv1, c__fpu_rsrv1_allocs = (C.__uint8_t)(x._FpuRsrv1), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_rsrv1_allocs)

	var c__fpu_fop_allocs *cgoAllocMap
	refa3972104.__fpu_fop, c__fpu_fop_allocs = (C.__uint16_t)(x._FpuFop), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_fop_allocs)

	var c__fpu_ip_allocs *cgoAllocMap
	refa3972104.__fpu_ip, c__fpu_ip_allocs = (C.__uint32_t)(x._FpuIp), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_ip_allocs)

	var c__fpu_cs_allocs *cgoAllocMap
	refa3972104.__fpu_cs, c__fpu_cs_allocs = (C.__uint16_t)(x._FpuCs), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_cs_allocs)

	var c__fpu_rsrv2_allocs *cgoAllocMap
	refa3972104.__fpu_rsrv2, c__fpu_rsrv2_allocs = (C.__uint16_t)(x._FpuRsrv2), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_rsrv2_allocs)

	var c__fpu_dp_allocs *cgoAllocMap
	refa3972104.__fpu_dp, c__fpu_dp_allocs = (C.__uint32_t)(x._FpuDp), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_dp_allocs)

	var c__fpu_ds_allocs *cgoAllocMap
	refa3972104.__fpu_ds, c__fpu_ds_allocs = (C.__uint16_t)(x._FpuDs), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_ds_allocs)

	var c__fpu_rsrv3_allocs *cgoAllocMap
	refa3972104.__fpu_rsrv3, c__fpu_rsrv3_allocs = (C.__uint16_t)(x._FpuRsrv3), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_rsrv3_allocs)

	var c__fpu_mxcsr_allocs *cgoAllocMap
	refa3972104.__fpu_mxcsr, c__fpu_mxcsr_allocs = (C.__uint32_t)(x._FpuMxcsr), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_mxcsr_allocs)

	var c__fpu_mxcsrmask_allocs *cgoAllocMap
	refa3972104.__fpu_mxcsrmask, c__fpu_mxcsrmask_allocs = (C.__uint32_t)(x._FpuMxcsrmask), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_mxcsrmask_allocs)

	var c__fpu_stmm0_allocs *cgoAllocMap
	refa3972104.__fpu_stmm0, c__fpu_stmm0_allocs = x._FpuStmm0.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm0_allocs)

	var c__fpu_stmm1_allocs *cgoAllocMap
	refa3972104.__fpu_stmm1, c__fpu_stmm1_allocs = x._FpuStmm1.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm1_allocs)

	var c__fpu_stmm2_allocs *cgoAllocMap
	refa3972104.__fpu_stmm2, c__fpu_stmm2_allocs = x._FpuStmm2.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm2_allocs)

	var c__fpu_stmm3_allocs *cgoAllocMap
	refa3972104.__fpu_stmm3, c__fpu_stmm3_allocs = x._FpuStmm3.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm3_allocs)

	var c__fpu_stmm4_allocs *cgoAllocMap
	refa3972104.__fpu_stmm4, c__fpu_stmm4_allocs = x._FpuStmm4.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm4_allocs)

	var c__fpu_stmm5_allocs *cgoAllocMap
	refa3972104.__fpu_stmm5, c__fpu_stmm5_allocs = x._FpuStmm5.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm5_allocs)

	var c__fpu_stmm6_allocs *cgoAllocMap
	refa3972104.__fpu_stmm6, c__fpu_stmm6_allocs = x._FpuStmm6.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm6_allocs)

	var c__fpu_stmm7_allocs *cgoAllocMap
	refa3972104.__fpu_stmm7, c__fpu_stmm7_allocs = x._FpuStmm7.PassValue()
	allocsa3972104.Borrow(c__fpu_stmm7_allocs)

	var c__fpu_xmm0_allocs *cgoAllocMap
	refa3972104.__fpu_xmm0, c__fpu_xmm0_allocs = x._FpuXmm0.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm0_allocs)

	var c__fpu_xmm1_allocs *cgoAllocMap
	refa3972104.__fpu_xmm1, c__fpu_xmm1_allocs = x._FpuXmm1.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm1_allocs)

	var c__fpu_xmm2_allocs *cgoAllocMap
	refa3972104.__fpu_xmm2, c__fpu_xmm2_allocs = x._FpuXmm2.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm2_allocs)

	var c__fpu_xmm3_allocs *cgoAllocMap
	refa3972104.__fpu_xmm3, c__fpu_xmm3_allocs = x._FpuXmm3.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm3_allocs)

	var c__fpu_xmm4_allocs *cgoAllocMap
	refa3972104.__fpu_xmm4, c__fpu_xmm4_allocs = x._FpuXmm4.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm4_allocs)

	var c__fpu_xmm5_allocs *cgoAllocMap
	refa3972104.__fpu_xmm5, c__fpu_xmm5_allocs = x._FpuXmm5.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm5_allocs)

	var c__fpu_xmm6_allocs *cgoAllocMap
	refa3972104.__fpu_xmm6, c__fpu_xmm6_allocs = x._FpuXmm6.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm6_allocs)

	var c__fpu_xmm7_allocs *cgoAllocMap
	refa3972104.__fpu_xmm7, c__fpu_xmm7_allocs = x._FpuXmm7.PassValue()
	allocsa3972104.Borrow(c__fpu_xmm7_allocs)

	var c__fpu_rsrv4_allocs *cgoAllocMap
	refa3972104.__fpu_rsrv4, c__fpu_rsrv4_allocs = *(*[224]C.char)(unsafe.Pointer(&x._FpuRsrv4)), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_rsrv4_allocs)

	var c__fpu_reserved1_allocs *cgoAllocMap
	refa3972104.__fpu_reserved1, c__fpu_reserved1_allocs = (C.int)(x._FpuReserved1), cgoAllocsUnknown
	allocsa3972104.Borrow(c__fpu_reserved1_allocs)

	x.refa3972104 = refa3972104
	x.allocsa3972104 = allocsa3972104
	return refa3972104, allocsa3972104

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinI386FloatState) PassValue() (C.struct___darwin_i386_float_state, *cgoAllocMap) {
	if x.refa3972104 != nil {
		return *x.refa3972104, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinI386FloatState) Deref() {
	if x.refa3972104 == nil {
		return
	}
	x._FpuReserved = *(*[2]int32)(unsafe.Pointer(&x.refa3972104.__fpu_reserved))
	x._FpuFcw = *New_DarwinFpControlRef(unsafe.Pointer(&x.refa3972104.__fpu_fcw))
	x._FpuFsw = *New_DarwinFpStatusRef(unsafe.Pointer(&x.refa3972104.__fpu_fsw))
	x._FpuFtw = (byte)(x.refa3972104.__fpu_ftw)
	x._FpuRsrv1 = (byte)(x.refa3972104.__fpu_rsrv1)
	x._FpuFop = (uint16)(x.refa3972104.__fpu_fop)
	x._FpuIp = (uint32)(x.refa3972104.__fpu_ip)
	x._FpuCs = (uint16)(x.refa3972104.__fpu_cs)
	x._FpuRsrv2 = (uint16)(x.refa3972104.__fpu_rsrv2)
	x._FpuDp = (uint32)(x.refa3972104.__fpu_dp)
	x._FpuDs = (uint16)(x.refa3972104.__fpu_ds)
	x._FpuRsrv3 = (uint16)(x.refa3972104.__fpu_rsrv3)
	x._FpuMxcsr = (uint32)(x.refa3972104.__fpu_mxcsr)
	x._FpuMxcsrmask = (uint32)(x.refa3972104.__fpu_mxcsrmask)
	x._FpuStmm0 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm0))
	x._FpuStmm1 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm1))
	x._FpuStmm2 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm2))
	x._FpuStmm3 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm3))
	x._FpuStmm4 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm4))
	x._FpuStmm5 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm5))
	x._FpuStmm6 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm6))
	x._FpuStmm7 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.refa3972104.__fpu_stmm7))
	x._FpuXmm0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm0))
	x._FpuXmm1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm1))
	x._FpuXmm2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm2))
	x._FpuXmm3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm3))
	x._FpuXmm4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm4))
	x._FpuXmm5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm5))
	x._FpuXmm6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm6))
	x._FpuXmm7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.refa3972104.__fpu_xmm7))
	x._FpuRsrv4 = *(*[224]byte)(unsafe.Pointer(&x.refa3972104.__fpu_rsrv4))
	x._FpuReserved1 = (int32)(x.refa3972104.__fpu_reserved1)
}

// allocStruct__DarwinI386ThreadStateMemory allocates memory for type C.struct___darwin_i386_thread_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinI386ThreadStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinI386ThreadStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinI386ThreadStateValue = unsafe.Sizeof([1]C.struct___darwin_i386_thread_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinI386ThreadState) Ref() *C.struct___darwin_i386_thread_state {
	if x == nil {
		return nil
	}
	return x.ref45d0404b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinI386ThreadState) Free() {
	if x != nil && x.allocs45d0404b != nil {
		x.allocs45d0404b.(*cgoAllocMap).Free()
		x.ref45d0404b = nil
	}
}

// New_DarwinI386ThreadStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinI386ThreadStateRef(ref unsafe.Pointer) *_DarwinI386ThreadState {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinI386ThreadState)
	obj.ref45d0404b = (*C.struct___darwin_i386_thread_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinI386ThreadState) PassRef() (*C.struct___darwin_i386_thread_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref45d0404b != nil {
		return x.ref45d0404b, nil
	}
	mem45d0404b := allocStruct__DarwinI386ThreadStateMemory(1)
	ref45d0404b := (*C.struct___darwin_i386_thread_state)(mem45d0404b)
	allocs45d0404b := new(cgoAllocMap)
	allocs45d0404b.Add(mem45d0404b)

	var c__eax_allocs *cgoAllocMap
	ref45d0404b.__eax, c__eax_allocs = (C.uint)(x._Eax), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__eax_allocs)

	var c__ebx_allocs *cgoAllocMap
	ref45d0404b.__ebx, c__ebx_allocs = (C.uint)(x._Ebx), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__ebx_allocs)

	var c__ecx_allocs *cgoAllocMap
	ref45d0404b.__ecx, c__ecx_allocs = (C.uint)(x._Ecx), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__ecx_allocs)

	var c__edx_allocs *cgoAllocMap
	ref45d0404b.__edx, c__edx_allocs = (C.uint)(x._Edx), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__edx_allocs)

	var c__edi_allocs *cgoAllocMap
	ref45d0404b.__edi, c__edi_allocs = (C.uint)(x._Edi), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__edi_allocs)

	var c__esi_allocs *cgoAllocMap
	ref45d0404b.__esi, c__esi_allocs = (C.uint)(x._Esi), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__esi_allocs)

	var c__ebp_allocs *cgoAllocMap
	ref45d0404b.__ebp, c__ebp_allocs = (C.uint)(x._Ebp), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__ebp_allocs)

	var c__esp_allocs *cgoAllocMap
	ref45d0404b.__esp, c__esp_allocs = (C.uint)(x._Esp), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__esp_allocs)

	var c__ss_allocs *cgoAllocMap
	ref45d0404b.__ss, c__ss_allocs = (C.uint)(x._Ss), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__ss_allocs)

	var c__eflags_allocs *cgoAllocMap
	ref45d0404b.__eflags, c__eflags_allocs = (C.uint)(x._Eflags), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__eflags_allocs)

	var c__eip_allocs *cgoAllocMap
	ref45d0404b.__eip, c__eip_allocs = (C.uint)(x._Eip), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__eip_allocs)

	var c__cs_allocs *cgoAllocMap
	ref45d0404b.__cs, c__cs_allocs = (C.uint)(x._Cs), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__cs_allocs)

	var c__ds_allocs *cgoAllocMap
	ref45d0404b.__ds, c__ds_allocs = (C.uint)(x._Ds), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__ds_allocs)

	var c__es_allocs *cgoAllocMap
	ref45d0404b.__es, c__es_allocs = (C.uint)(x._Es), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__es_allocs)

	var c__fs_allocs *cgoAllocMap
	ref45d0404b.__fs, c__fs_allocs = (C.uint)(x._Fs), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__fs_allocs)

	var c__gs_allocs *cgoAllocMap
	ref45d0404b.__gs, c__gs_allocs = (C.uint)(x._Gs), cgoAllocsUnknown
	allocs45d0404b.Borrow(c__gs_allocs)

	x.ref45d0404b = ref45d0404b
	x.allocs45d0404b = allocs45d0404b
	return ref45d0404b, allocs45d0404b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinI386ThreadState) PassValue() (C.struct___darwin_i386_thread_state, *cgoAllocMap) {
	if x.ref45d0404b != nil {
		return *x.ref45d0404b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinI386ThreadState) Deref() {
	if x.ref45d0404b == nil {
		return
	}
	x._Eax = (uint32)(x.ref45d0404b.__eax)
	x._Ebx = (uint32)(x.ref45d0404b.__ebx)
	x._Ecx = (uint32)(x.ref45d0404b.__ecx)
	x._Edx = (uint32)(x.ref45d0404b.__edx)
	x._Edi = (uint32)(x.ref45d0404b.__edi)
	x._Esi = (uint32)(x.ref45d0404b.__esi)
	x._Ebp = (uint32)(x.ref45d0404b.__ebp)
	x._Esp = (uint32)(x.ref45d0404b.__esp)
	x._Ss = (uint32)(x.ref45d0404b.__ss)
	x._Eflags = (uint32)(x.ref45d0404b.__eflags)
	x._Eip = (uint32)(x.ref45d0404b.__eip)
	x._Cs = (uint32)(x.ref45d0404b.__cs)
	x._Ds = (uint32)(x.ref45d0404b.__ds)
	x._Es = (uint32)(x.ref45d0404b.__es)
	x._Fs = (uint32)(x.ref45d0404b.__fs)
	x._Gs = (uint32)(x.ref45d0404b.__gs)
}

// allocStruct__DarwinMcontext32Memory allocates memory for type C.struct___darwin_mcontext32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontext32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontext32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontext32Value = unsafe.Sizeof([1]C.struct___darwin_mcontext32{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontext32) Ref() *C.struct___darwin_mcontext32 {
	if x == nil {
		return nil
	}
	return x.ref5566d785
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontext32) Free() {
	if x != nil && x.allocs5566d785 != nil {
		x.allocs5566d785.(*cgoAllocMap).Free()
		x.ref5566d785 = nil
	}
}

// New_DarwinMcontext32Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontext32Ref(ref unsafe.Pointer) *_DarwinMcontext32 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontext32)
	obj.ref5566d785 = (*C.struct___darwin_mcontext32)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontext32) PassRef() (*C.struct___darwin_mcontext32, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5566d785 != nil {
		return x.ref5566d785, nil
	}
	mem5566d785 := allocStruct__DarwinMcontext32Memory(1)
	ref5566d785 := (*C.struct___darwin_mcontext32)(mem5566d785)
	allocs5566d785 := new(cgoAllocMap)
	allocs5566d785.Add(mem5566d785)

	var c__es_allocs *cgoAllocMap
	ref5566d785.__es, c__es_allocs = x._Es.PassValue()
	allocs5566d785.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	ref5566d785.__ss, c__ss_allocs = x._Ss.PassValue()
	allocs5566d785.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	ref5566d785.__fs, c__fs_allocs = x._Fs.PassValue()
	allocs5566d785.Borrow(c__fs_allocs)

	x.ref5566d785 = ref5566d785
	x.allocs5566d785 = allocs5566d785
	return ref5566d785, allocs5566d785

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontext32) PassValue() (C.struct___darwin_mcontext32, *cgoAllocMap) {
	if x.ref5566d785 != nil {
		return *x.ref5566d785, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontext32) Deref() {
	if x.ref5566d785 == nil {
		return
	}
	x._Es = *New_DarwinI386ExceptionStateRef(unsafe.Pointer(&x.ref5566d785.__es))
	x._Ss = *New_DarwinI386ThreadStateRef(unsafe.Pointer(&x.ref5566d785.__ss))
	x._Fs = *New_DarwinI386FloatStateRef(unsafe.Pointer(&x.ref5566d785.__fs))
}

// allocMcontextMemory allocates memory for type C.mcontext_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMcontextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMcontextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfMcontextValue = unsafe.Sizeof([1]C.mcontext_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Mcontext) Ref() *C.mcontext_t {
	if x == nil {
		return nil
	}
	return x.ref1645c3e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Mcontext) Free() {
	if x != nil && x.allocs1645c3e1 != nil {
		x.allocs1645c3e1.(*cgoAllocMap).Free()
		x.ref1645c3e1 = nil
	}
}

// NewMcontextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMcontextRef(ref unsafe.Pointer) *Mcontext {
	if ref == nil {
		return nil
	}
	obj := new(Mcontext)
	obj.ref1645c3e1 = (*C.mcontext_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Mcontext) PassRef() (*C.mcontext_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1645c3e1 != nil {
		return x.ref1645c3e1, nil
	}
	mem1645c3e1 := allocMcontextMemory(1)
	ref1645c3e1 := (*C.mcontext_t)(mem1645c3e1)
	allocs1645c3e1 := new(cgoAllocMap)
	allocs1645c3e1.Add(mem1645c3e1)

	var c__es_allocs *cgoAllocMap
	ref1645c3e1.__es, c__es_allocs = x._Es.PassValue()
	allocs1645c3e1.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	ref1645c3e1.__ss, c__ss_allocs = x._Ss.PassValue()
	allocs1645c3e1.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	ref1645c3e1.__fs, c__fs_allocs = x._Fs.PassValue()
	allocs1645c3e1.Borrow(c__fs_allocs)

	x.ref1645c3e1 = ref1645c3e1
	x.allocs1645c3e1 = allocs1645c3e1
	return ref1645c3e1, allocs1645c3e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Mcontext) PassValue() (C.mcontext_t, *cgoAllocMap) {
	if x.ref1645c3e1 != nil {
		return *x.ref1645c3e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Mcontext) Deref() {
	if x.ref1645c3e1 == nil {
		return
	}
	x._Es = *New_DarwinX86ExceptionState64Ref(unsafe.Pointer(&x.ref1645c3e1.__es))
	x._Ss = *New_DarwinX86ThreadState64Ref(unsafe.Pointer(&x.ref1645c3e1.__ss))
	x._Fs = *New_DarwinX86FloatState64Ref(unsafe.Pointer(&x.ref1645c3e1.__fs))
}

// allocStruct__DarwinMcontext64FullMemory allocates memory for type C.struct___darwin_mcontext64_full in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontext64FullMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontext64FullValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontext64FullValue = unsafe.Sizeof([1]C.struct___darwin_mcontext64_full{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontext64Full) Ref() *C.struct___darwin_mcontext64_full {
	if x == nil {
		return nil
	}
	return x.ref7028c840
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontext64Full) Free() {
	if x != nil && x.allocs7028c840 != nil {
		x.allocs7028c840.(*cgoAllocMap).Free()
		x.ref7028c840 = nil
	}
}

// New_DarwinMcontext64FullRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontext64FullRef(ref unsafe.Pointer) *_DarwinMcontext64Full {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontext64Full)
	obj.ref7028c840 = (*C.struct___darwin_mcontext64_full)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontext64Full) PassRef() (*C.struct___darwin_mcontext64_full, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7028c840 != nil {
		return x.ref7028c840, nil
	}
	mem7028c840 := allocStruct__DarwinMcontext64FullMemory(1)
	ref7028c840 := (*C.struct___darwin_mcontext64_full)(mem7028c840)
	allocs7028c840 := new(cgoAllocMap)
	allocs7028c840.Add(mem7028c840)

	var c__es_allocs *cgoAllocMap
	ref7028c840.__es, c__es_allocs = x._Es.PassValue()
	allocs7028c840.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	ref7028c840.__ss, c__ss_allocs = x._Ss.PassValue()
	allocs7028c840.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	ref7028c840.__fs, c__fs_allocs = x._Fs.PassValue()
	allocs7028c840.Borrow(c__fs_allocs)

	x.ref7028c840 = ref7028c840
	x.allocs7028c840 = allocs7028c840
	return ref7028c840, allocs7028c840

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontext64Full) PassValue() (C.struct___darwin_mcontext64_full, *cgoAllocMap) {
	if x.ref7028c840 != nil {
		return *x.ref7028c840, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontext64Full) Deref() {
	if x.ref7028c840 == nil {
		return
	}
	x._Es = *New_DarwinX86ExceptionState64Ref(unsafe.Pointer(&x.ref7028c840.__es))
	x._Ss = *New_DarwinX86ThreadFullState64Ref(unsafe.Pointer(&x.ref7028c840.__ss))
	x._Fs = *New_DarwinX86FloatState64Ref(unsafe.Pointer(&x.ref7028c840.__fs))
}

// allocStruct__DarwinMcontextAvx32Memory allocates memory for type C.struct___darwin_mcontext_avx32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontextAvx32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontextAvx32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontextAvx32Value = unsafe.Sizeof([1]C.struct___darwin_mcontext_avx32{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontextAvx32) Ref() *C.struct___darwin_mcontext_avx32 {
	if x == nil {
		return nil
	}
	return x.ref732c5bd8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontextAvx32) Free() {
	if x != nil && x.allocs732c5bd8 != nil {
		x.allocs732c5bd8.(*cgoAllocMap).Free()
		x.ref732c5bd8 = nil
	}
}

// New_DarwinMcontextAvx32Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontextAvx32Ref(ref unsafe.Pointer) *_DarwinMcontextAvx32 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontextAvx32)
	obj.ref732c5bd8 = (*C.struct___darwin_mcontext_avx32)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontextAvx32) PassRef() (*C.struct___darwin_mcontext_avx32, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref732c5bd8 != nil {
		return x.ref732c5bd8, nil
	}
	mem732c5bd8 := allocStruct__DarwinMcontextAvx32Memory(1)
	ref732c5bd8 := (*C.struct___darwin_mcontext_avx32)(mem732c5bd8)
	allocs732c5bd8 := new(cgoAllocMap)
	allocs732c5bd8.Add(mem732c5bd8)

	var c__es_allocs *cgoAllocMap
	ref732c5bd8.__es, c__es_allocs = x._Es.PassValue()
	allocs732c5bd8.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	ref732c5bd8.__ss, c__ss_allocs = x._Ss.PassValue()
	allocs732c5bd8.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	ref732c5bd8.__fs, c__fs_allocs = x._Fs.PassValue()
	allocs732c5bd8.Borrow(c__fs_allocs)

	x.ref732c5bd8 = ref732c5bd8
	x.allocs732c5bd8 = allocs732c5bd8
	return ref732c5bd8, allocs732c5bd8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontextAvx32) PassValue() (C.struct___darwin_mcontext_avx32, *cgoAllocMap) {
	if x.ref732c5bd8 != nil {
		return *x.ref732c5bd8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontextAvx32) Deref() {
	if x.ref732c5bd8 == nil {
		return
	}
	x._Es = *New_DarwinI386ExceptionStateRef(unsafe.Pointer(&x.ref732c5bd8.__es))
	x._Ss = *New_DarwinI386ThreadStateRef(unsafe.Pointer(&x.ref732c5bd8.__ss))
	x._Fs = *New_DarwinI386AvxStateRef(unsafe.Pointer(&x.ref732c5bd8.__fs))
}

// allocStruct__DarwinMcontextAvx51232Memory allocates memory for type C.struct___darwin_mcontext_avx512_32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontextAvx51232Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontextAvx51232Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontextAvx51232Value = unsafe.Sizeof([1]C.struct___darwin_mcontext_avx512_32{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontextAvx51232) Ref() *C.struct___darwin_mcontext_avx512_32 {
	if x == nil {
		return nil
	}
	return x.refc2f730c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontextAvx51232) Free() {
	if x != nil && x.allocsc2f730c9 != nil {
		x.allocsc2f730c9.(*cgoAllocMap).Free()
		x.refc2f730c9 = nil
	}
}

// New_DarwinMcontextAvx51232Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontextAvx51232Ref(ref unsafe.Pointer) *_DarwinMcontextAvx51232 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontextAvx51232)
	obj.refc2f730c9 = (*C.struct___darwin_mcontext_avx512_32)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontextAvx51232) PassRef() (*C.struct___darwin_mcontext_avx512_32, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc2f730c9 != nil {
		return x.refc2f730c9, nil
	}
	memc2f730c9 := allocStruct__DarwinMcontextAvx51232Memory(1)
	refc2f730c9 := (*C.struct___darwin_mcontext_avx512_32)(memc2f730c9)
	allocsc2f730c9 := new(cgoAllocMap)
	allocsc2f730c9.Add(memc2f730c9)

	var c__es_allocs *cgoAllocMap
	refc2f730c9.__es, c__es_allocs = x._Es.PassValue()
	allocsc2f730c9.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	refc2f730c9.__ss, c__ss_allocs = x._Ss.PassValue()
	allocsc2f730c9.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	refc2f730c9.__fs, c__fs_allocs = x._Fs.PassValue()
	allocsc2f730c9.Borrow(c__fs_allocs)

	x.refc2f730c9 = refc2f730c9
	x.allocsc2f730c9 = allocsc2f730c9
	return refc2f730c9, allocsc2f730c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontextAvx51232) PassValue() (C.struct___darwin_mcontext_avx512_32, *cgoAllocMap) {
	if x.refc2f730c9 != nil {
		return *x.refc2f730c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontextAvx51232) Deref() {
	if x.refc2f730c9 == nil {
		return
	}
	x._Es = *New_DarwinI386ExceptionStateRef(unsafe.Pointer(&x.refc2f730c9.__es))
	x._Ss = *New_DarwinI386ThreadStateRef(unsafe.Pointer(&x.refc2f730c9.__ss))
	x._Fs = *New_DarwinI386Avx512StateRef(unsafe.Pointer(&x.refc2f730c9.__fs))
}

// allocStruct__DarwinMcontextAvx51264Memory allocates memory for type C.struct___darwin_mcontext_avx512_64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontextAvx51264Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontextAvx51264Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontextAvx51264Value = unsafe.Sizeof([1]C.struct___darwin_mcontext_avx512_64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontextAvx51264) Ref() *C.struct___darwin_mcontext_avx512_64 {
	if x == nil {
		return nil
	}
	return x.ref56e361b9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontextAvx51264) Free() {
	if x != nil && x.allocs56e361b9 != nil {
		x.allocs56e361b9.(*cgoAllocMap).Free()
		x.ref56e361b9 = nil
	}
}

// New_DarwinMcontextAvx51264Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontextAvx51264Ref(ref unsafe.Pointer) *_DarwinMcontextAvx51264 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontextAvx51264)
	obj.ref56e361b9 = (*C.struct___darwin_mcontext_avx512_64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontextAvx51264) PassRef() (*C.struct___darwin_mcontext_avx512_64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56e361b9 != nil {
		return x.ref56e361b9, nil
	}
	mem56e361b9 := allocStruct__DarwinMcontextAvx51264Memory(1)
	ref56e361b9 := (*C.struct___darwin_mcontext_avx512_64)(mem56e361b9)
	allocs56e361b9 := new(cgoAllocMap)
	allocs56e361b9.Add(mem56e361b9)

	var c__es_allocs *cgoAllocMap
	ref56e361b9.__es, c__es_allocs = x._Es.PassValue()
	allocs56e361b9.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	ref56e361b9.__ss, c__ss_allocs = x._Ss.PassValue()
	allocs56e361b9.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	ref56e361b9.__fs, c__fs_allocs = x._Fs.PassValue()
	allocs56e361b9.Borrow(c__fs_allocs)

	x.ref56e361b9 = ref56e361b9
	x.allocs56e361b9 = allocs56e361b9
	return ref56e361b9, allocs56e361b9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontextAvx51264) PassValue() (C.struct___darwin_mcontext_avx512_64, *cgoAllocMap) {
	if x.ref56e361b9 != nil {
		return *x.ref56e361b9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontextAvx51264) Deref() {
	if x.ref56e361b9 == nil {
		return
	}
	x._Es = *New_DarwinX86ExceptionState64Ref(unsafe.Pointer(&x.ref56e361b9.__es))
	x._Ss = *New_DarwinX86ThreadState64Ref(unsafe.Pointer(&x.ref56e361b9.__ss))
	x._Fs = *New_DarwinX86Avx512State64Ref(unsafe.Pointer(&x.ref56e361b9.__fs))
}

// allocStruct__DarwinMcontextAvx51264FullMemory allocates memory for type C.struct___darwin_mcontext_avx512_64_full in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontextAvx51264FullMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontextAvx51264FullValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontextAvx51264FullValue = unsafe.Sizeof([1]C.struct___darwin_mcontext_avx512_64_full{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontextAvx51264Full) Ref() *C.struct___darwin_mcontext_avx512_64_full {
	if x == nil {
		return nil
	}
	return x.ref6452ca93
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontextAvx51264Full) Free() {
	if x != nil && x.allocs6452ca93 != nil {
		x.allocs6452ca93.(*cgoAllocMap).Free()
		x.ref6452ca93 = nil
	}
}

// New_DarwinMcontextAvx51264FullRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontextAvx51264FullRef(ref unsafe.Pointer) *_DarwinMcontextAvx51264Full {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontextAvx51264Full)
	obj.ref6452ca93 = (*C.struct___darwin_mcontext_avx512_64_full)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontextAvx51264Full) PassRef() (*C.struct___darwin_mcontext_avx512_64_full, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6452ca93 != nil {
		return x.ref6452ca93, nil
	}
	mem6452ca93 := allocStruct__DarwinMcontextAvx51264FullMemory(1)
	ref6452ca93 := (*C.struct___darwin_mcontext_avx512_64_full)(mem6452ca93)
	allocs6452ca93 := new(cgoAllocMap)
	allocs6452ca93.Add(mem6452ca93)

	var c__es_allocs *cgoAllocMap
	ref6452ca93.__es, c__es_allocs = x._Es.PassValue()
	allocs6452ca93.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	ref6452ca93.__ss, c__ss_allocs = x._Ss.PassValue()
	allocs6452ca93.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	ref6452ca93.__fs, c__fs_allocs = x._Fs.PassValue()
	allocs6452ca93.Borrow(c__fs_allocs)

	x.ref6452ca93 = ref6452ca93
	x.allocs6452ca93 = allocs6452ca93
	return ref6452ca93, allocs6452ca93

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontextAvx51264Full) PassValue() (C.struct___darwin_mcontext_avx512_64_full, *cgoAllocMap) {
	if x.ref6452ca93 != nil {
		return *x.ref6452ca93, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontextAvx51264Full) Deref() {
	if x.ref6452ca93 == nil {
		return
	}
	x._Es = *New_DarwinX86ExceptionState64Ref(unsafe.Pointer(&x.ref6452ca93.__es))
	x._Ss = *New_DarwinX86ThreadFullState64Ref(unsafe.Pointer(&x.ref6452ca93.__ss))
	x._Fs = *New_DarwinX86Avx512State64Ref(unsafe.Pointer(&x.ref6452ca93.__fs))
}

// allocStruct__DarwinMcontextAvx64Memory allocates memory for type C.struct___darwin_mcontext_avx64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontextAvx64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontextAvx64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontextAvx64Value = unsafe.Sizeof([1]C.struct___darwin_mcontext_avx64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontextAvx64) Ref() *C.struct___darwin_mcontext_avx64 {
	if x == nil {
		return nil
	}
	return x.refe7380aa8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontextAvx64) Free() {
	if x != nil && x.allocse7380aa8 != nil {
		x.allocse7380aa8.(*cgoAllocMap).Free()
		x.refe7380aa8 = nil
	}
}

// New_DarwinMcontextAvx64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontextAvx64Ref(ref unsafe.Pointer) *_DarwinMcontextAvx64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontextAvx64)
	obj.refe7380aa8 = (*C.struct___darwin_mcontext_avx64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontextAvx64) PassRef() (*C.struct___darwin_mcontext_avx64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe7380aa8 != nil {
		return x.refe7380aa8, nil
	}
	meme7380aa8 := allocStruct__DarwinMcontextAvx64Memory(1)
	refe7380aa8 := (*C.struct___darwin_mcontext_avx64)(meme7380aa8)
	allocse7380aa8 := new(cgoAllocMap)
	allocse7380aa8.Add(meme7380aa8)

	var c__es_allocs *cgoAllocMap
	refe7380aa8.__es, c__es_allocs = x._Es.PassValue()
	allocse7380aa8.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	refe7380aa8.__ss, c__ss_allocs = x._Ss.PassValue()
	allocse7380aa8.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	refe7380aa8.__fs, c__fs_allocs = x._Fs.PassValue()
	allocse7380aa8.Borrow(c__fs_allocs)

	x.refe7380aa8 = refe7380aa8
	x.allocse7380aa8 = allocse7380aa8
	return refe7380aa8, allocse7380aa8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontextAvx64) PassValue() (C.struct___darwin_mcontext_avx64, *cgoAllocMap) {
	if x.refe7380aa8 != nil {
		return *x.refe7380aa8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontextAvx64) Deref() {
	if x.refe7380aa8 == nil {
		return
	}
	x._Es = *New_DarwinX86ExceptionState64Ref(unsafe.Pointer(&x.refe7380aa8.__es))
	x._Ss = *New_DarwinX86ThreadState64Ref(unsafe.Pointer(&x.refe7380aa8.__ss))
	x._Fs = *New_DarwinX86AvxState64Ref(unsafe.Pointer(&x.refe7380aa8.__fs))
}

// allocStruct__DarwinMcontextAvx64FullMemory allocates memory for type C.struct___darwin_mcontext_avx64_full in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMcontextAvx64FullMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMcontextAvx64FullValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMcontextAvx64FullValue = unsafe.Sizeof([1]C.struct___darwin_mcontext_avx64_full{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMcontextAvx64Full) Ref() *C.struct___darwin_mcontext_avx64_full {
	if x == nil {
		return nil
	}
	return x.refa9f7418b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMcontextAvx64Full) Free() {
	if x != nil && x.allocsa9f7418b != nil {
		x.allocsa9f7418b.(*cgoAllocMap).Free()
		x.refa9f7418b = nil
	}
}

// New_DarwinMcontextAvx64FullRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMcontextAvx64FullRef(ref unsafe.Pointer) *_DarwinMcontextAvx64Full {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMcontextAvx64Full)
	obj.refa9f7418b = (*C.struct___darwin_mcontext_avx64_full)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMcontextAvx64Full) PassRef() (*C.struct___darwin_mcontext_avx64_full, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9f7418b != nil {
		return x.refa9f7418b, nil
	}
	mema9f7418b := allocStruct__DarwinMcontextAvx64FullMemory(1)
	refa9f7418b := (*C.struct___darwin_mcontext_avx64_full)(mema9f7418b)
	allocsa9f7418b := new(cgoAllocMap)
	allocsa9f7418b.Add(mema9f7418b)

	var c__es_allocs *cgoAllocMap
	refa9f7418b.__es, c__es_allocs = x._Es.PassValue()
	allocsa9f7418b.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	refa9f7418b.__ss, c__ss_allocs = x._Ss.PassValue()
	allocsa9f7418b.Borrow(c__ss_allocs)

	var c__fs_allocs *cgoAllocMap
	refa9f7418b.__fs, c__fs_allocs = x._Fs.PassValue()
	allocsa9f7418b.Borrow(c__fs_allocs)

	x.refa9f7418b = refa9f7418b
	x.allocsa9f7418b = allocsa9f7418b
	return refa9f7418b, allocsa9f7418b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMcontextAvx64Full) PassValue() (C.struct___darwin_mcontext_avx64_full, *cgoAllocMap) {
	if x.refa9f7418b != nil {
		return *x.refa9f7418b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMcontextAvx64Full) Deref() {
	if x.refa9f7418b == nil {
		return
	}
	x._Es = *New_DarwinX86ExceptionState64Ref(unsafe.Pointer(&x.refa9f7418b.__es))
	x._Ss = *New_DarwinX86ThreadFullState64Ref(unsafe.Pointer(&x.refa9f7418b.__ss))
	x._Fs = *New_DarwinX86AvxState64Ref(unsafe.Pointer(&x.refa9f7418b.__fs))
}

// allocStruct__DarwinMmstRegMemory allocates memory for type C.struct___darwin_mmst_reg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinMmstRegMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinMmstRegValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinMmstRegValue = unsafe.Sizeof([1]C.struct___darwin_mmst_reg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinMmstReg) Ref() *C.struct___darwin_mmst_reg {
	if x == nil {
		return nil
	}
	return x.ref89d6b8d7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinMmstReg) Free() {
	if x != nil && x.allocs89d6b8d7 != nil {
		x.allocs89d6b8d7.(*cgoAllocMap).Free()
		x.ref89d6b8d7 = nil
	}
}

// New_DarwinMmstRegRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinMmstRegRef(ref unsafe.Pointer) *_DarwinMmstReg {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinMmstReg)
	obj.ref89d6b8d7 = (*C.struct___darwin_mmst_reg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinMmstReg) PassRef() (*C.struct___darwin_mmst_reg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89d6b8d7 != nil {
		return x.ref89d6b8d7, nil
	}
	mem89d6b8d7 := allocStruct__DarwinMmstRegMemory(1)
	ref89d6b8d7 := (*C.struct___darwin_mmst_reg)(mem89d6b8d7)
	allocs89d6b8d7 := new(cgoAllocMap)
	allocs89d6b8d7.Add(mem89d6b8d7)

	var c__mmst_reg_allocs *cgoAllocMap
	ref89d6b8d7.__mmst_reg, c__mmst_reg_allocs = *(*[10]C.char)(unsafe.Pointer(&x._MmstReg)), cgoAllocsUnknown
	allocs89d6b8d7.Borrow(c__mmst_reg_allocs)

	var c__mmst_rsrv_allocs *cgoAllocMap
	ref89d6b8d7.__mmst_rsrv, c__mmst_rsrv_allocs = *(*[6]C.char)(unsafe.Pointer(&x._MmstRsrv)), cgoAllocsUnknown
	allocs89d6b8d7.Borrow(c__mmst_rsrv_allocs)

	x.ref89d6b8d7 = ref89d6b8d7
	x.allocs89d6b8d7 = allocs89d6b8d7
	return ref89d6b8d7, allocs89d6b8d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinMmstReg) PassValue() (C.struct___darwin_mmst_reg, *cgoAllocMap) {
	if x.ref89d6b8d7 != nil {
		return *x.ref89d6b8d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinMmstReg) Deref() {
	if x.ref89d6b8d7 == nil {
		return
	}
	x._MmstReg = *(*[10]byte)(unsafe.Pointer(&x.ref89d6b8d7.__mmst_reg))
	x._MmstRsrv = *(*[6]byte)(unsafe.Pointer(&x.ref89d6b8d7.__mmst_rsrv))
}

// allocStruct__DarwinOpmaskRegMemory allocates memory for type C.struct___darwin_opmask_reg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinOpmaskRegMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinOpmaskRegValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinOpmaskRegValue = unsafe.Sizeof([1]C.struct___darwin_opmask_reg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinOpmaskReg) Ref() *C.struct___darwin_opmask_reg {
	if x == nil {
		return nil
	}
	return x.ref1c0e34dd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinOpmaskReg) Free() {
	if x != nil && x.allocs1c0e34dd != nil {
		x.allocs1c0e34dd.(*cgoAllocMap).Free()
		x.ref1c0e34dd = nil
	}
}

// New_DarwinOpmaskRegRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinOpmaskRegRef(ref unsafe.Pointer) *_DarwinOpmaskReg {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinOpmaskReg)
	obj.ref1c0e34dd = (*C.struct___darwin_opmask_reg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinOpmaskReg) PassRef() (*C.struct___darwin_opmask_reg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1c0e34dd != nil {
		return x.ref1c0e34dd, nil
	}
	mem1c0e34dd := allocStruct__DarwinOpmaskRegMemory(1)
	ref1c0e34dd := (*C.struct___darwin_opmask_reg)(mem1c0e34dd)
	allocs1c0e34dd := new(cgoAllocMap)
	allocs1c0e34dd.Add(mem1c0e34dd)

	var c__opmask_reg_allocs *cgoAllocMap
	ref1c0e34dd.__opmask_reg, c__opmask_reg_allocs = *(*[8]C.char)(unsafe.Pointer(&x._OpmaskReg)), cgoAllocsUnknown
	allocs1c0e34dd.Borrow(c__opmask_reg_allocs)

	x.ref1c0e34dd = ref1c0e34dd
	x.allocs1c0e34dd = allocs1c0e34dd
	return ref1c0e34dd, allocs1c0e34dd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinOpmaskReg) PassValue() (C.struct___darwin_opmask_reg, *cgoAllocMap) {
	if x.ref1c0e34dd != nil {
		return *x.ref1c0e34dd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinOpmaskReg) Deref() {
	if x.ref1c0e34dd == nil {
		return
	}
	x._OpmaskReg = *(*[8]byte)(unsafe.Pointer(&x.ref1c0e34dd.__opmask_reg))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinPthreadHandlerRec) Ref() *C.struct___darwin_pthread_handler_rec {
	if x == nil {
		return nil
	}
	return x.refdc59d4e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinPthreadHandlerRec) Free() {
	if x != nil && x.allocsdc59d4e != nil {
		x.allocsdc59d4e.(*cgoAllocMap).Free()
		x.refdc59d4e = nil
	}
}

// New_DarwinPthreadHandlerRecRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinPthreadHandlerRecRef(ref unsafe.Pointer) *_DarwinPthreadHandlerRec {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinPthreadHandlerRec)
	obj.refdc59d4e = (*C.struct___darwin_pthread_handler_rec)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinPthreadHandlerRec) PassRef() (*C.struct___darwin_pthread_handler_rec, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc59d4e != nil {
		return x.refdc59d4e, nil
	}
	memdc59d4e := allocStruct__DarwinPthreadHandlerRecMemory(1)
	refdc59d4e := (*C.struct___darwin_pthread_handler_rec)(memdc59d4e)
	allocsdc59d4e := new(cgoAllocMap)
	allocsdc59d4e.Add(memdc59d4e)

	var c__routine_allocs *cgoAllocMap
	refdc59d4e.__routine, c__routine_allocs = x._Routine.PassRef()
	allocsdc59d4e.Borrow(c__routine_allocs)

	var c__arg_allocs *cgoAllocMap
	refdc59d4e.__arg, c__arg_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x._Arg)), cgoAllocsUnknown
	allocsdc59d4e.Borrow(c__arg_allocs)

	var c__next_allocs *cgoAllocMap
	refdc59d4e.__next, c__next_allocs = unpackS_DarwinPthreadHandlerRec(x._Next)
	allocsdc59d4e.Borrow(c__next_allocs)

	x.refdc59d4e = refdc59d4e
	x.allocsdc59d4e = allocsdc59d4e
	return refdc59d4e, allocsdc59d4e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinPthreadHandlerRec) PassValue() (C.struct___darwin_pthread_handler_rec, *cgoAllocMap) {
	if x.refdc59d4e != nil {
		return *x.refdc59d4e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinPthreadHandlerRec) Deref() {
	if x.refdc59d4e == nil {
		return
	}
	x._Routine = NewRef(unsafe.Pointer(x.refdc59d4e.__routine))
	x._Arg = (unsafe.Pointer)(unsafe.Pointer(x.refdc59d4e.__arg))
	packS_DarwinPthreadHandlerRec(x._Next, x.refdc59d4e.__next)
}

// allocStackMemory allocates memory for type C.stack_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStackMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStackValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStackValue = unsafe.Sizeof([1]C.stack_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Stack) Ref() *C.stack_t {
	if x == nil {
		return nil
	}
	return x.ref73578c70
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Stack) Free() {
	if x != nil && x.allocs73578c70 != nil {
		x.allocs73578c70.(*cgoAllocMap).Free()
		x.ref73578c70 = nil
	}
}

// NewStackRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewStackRef(ref unsafe.Pointer) *Stack {
	if ref == nil {
		return nil
	}
	obj := new(Stack)
	obj.ref73578c70 = (*C.stack_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Stack) PassRef() (*C.stack_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73578c70 != nil {
		return x.ref73578c70, nil
	}
	mem73578c70 := allocStackMemory(1)
	ref73578c70 := (*C.stack_t)(mem73578c70)
	allocs73578c70 := new(cgoAllocMap)
	allocs73578c70.Add(mem73578c70)

	var css_sp_allocs *cgoAllocMap
	ref73578c70.ss_sp, css_sp_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.SsSp)), cgoAllocsUnknown
	allocs73578c70.Borrow(css_sp_allocs)

	var css_size_allocs *cgoAllocMap
	ref73578c70.ss_size, css_size_allocs = (C.__darwin_size_t)(x.SsSize), cgoAllocsUnknown
	allocs73578c70.Borrow(css_size_allocs)

	var css_flags_allocs *cgoAllocMap
	ref73578c70.ss_flags, css_flags_allocs = (C.int)(x.SsFlags), cgoAllocsUnknown
	allocs73578c70.Borrow(css_flags_allocs)

	x.ref73578c70 = ref73578c70
	x.allocs73578c70 = allocs73578c70
	return ref73578c70, allocs73578c70

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Stack) PassValue() (C.stack_t, *cgoAllocMap) {
	if x.ref73578c70 != nil {
		return *x.ref73578c70, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Stack) Deref() {
	if x.ref73578c70 == nil {
		return
	}
	x.SsSp = (unsafe.Pointer)(unsafe.Pointer(x.ref73578c70.ss_sp))
	x.SsSize = (_DarwinSize)(x.ref73578c70.ss_size)
	x.SsFlags = (int32)(x.ref73578c70.ss_flags)
}

// allocUcontextMemory allocates memory for type C.ucontext_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUcontextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcontextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUcontextValue = unsafe.Sizeof([1]C.ucontext_t{})

// allocStruct__DarwinUcontextMemory allocates memory for type C.struct___darwin_ucontext in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinUcontextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinUcontextValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinUcontextValue = unsafe.Sizeof([1]C.struct___darwin_ucontext{})

// unpackS_DarwinUcontext transforms a sliced Go data structure into plain C format.
func unpackS_DarwinUcontext(x []_DarwinUcontext) (unpacked *C.struct___darwin_ucontext, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocStruct__DarwinUcontextMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct___darwin_ucontext)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct___darwin_ucontext)(h.Data)
	return
}

// packS_DarwinUcontext reads sliced Go data structure out from plain C format.
func packS_DarwinUcontext(v []_DarwinUcontext, ptr0 *C.struct___darwin_ucontext) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStruct__DarwinUcontextValue]C.struct___darwin_ucontext)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *New_DarwinUcontextRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Ucontext) Ref() *C.ucontext_t {
	if x == nil {
		return nil
	}
	return x.ref121f15cf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Ucontext) Free() {
	if x != nil && x.allocs121f15cf != nil {
		x.allocs121f15cf.(*cgoAllocMap).Free()
		x.ref121f15cf = nil
	}
}

// NewUcontextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUcontextRef(ref unsafe.Pointer) *Ucontext {
	if ref == nil {
		return nil
	}
	obj := new(Ucontext)
	obj.ref121f15cf = (*C.ucontext_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Ucontext) PassRef() (*C.ucontext_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref121f15cf != nil {
		return x.ref121f15cf, nil
	}
	mem121f15cf := allocUcontextMemory(1)
	ref121f15cf := (*C.ucontext_t)(mem121f15cf)
	allocs121f15cf := new(cgoAllocMap)
	allocs121f15cf.Add(mem121f15cf)

	var cuc_onstack_allocs *cgoAllocMap
	ref121f15cf.uc_onstack, cuc_onstack_allocs = (C.int)(x.UcOnstack), cgoAllocsUnknown
	allocs121f15cf.Borrow(cuc_onstack_allocs)

	var cuc_sigmask_allocs *cgoAllocMap
	ref121f15cf.uc_sigmask, cuc_sigmask_allocs = (C.__darwin_sigset_t)(x.UcSigmask), cgoAllocsUnknown
	allocs121f15cf.Borrow(cuc_sigmask_allocs)

	var cuc_stack_allocs *cgoAllocMap
	ref121f15cf.uc_stack, cuc_stack_allocs = x.UcStack.PassValue()
	allocs121f15cf.Borrow(cuc_stack_allocs)

	var cuc_link_allocs *cgoAllocMap
	ref121f15cf.uc_link, cuc_link_allocs = unpackS_DarwinUcontext(x.UcLink)
	allocs121f15cf.Borrow(cuc_link_allocs)

	var cuc_mcsize_allocs *cgoAllocMap
	ref121f15cf.uc_mcsize, cuc_mcsize_allocs = (C.__darwin_size_t)(x.UcMcsize), cgoAllocsUnknown
	allocs121f15cf.Borrow(cuc_mcsize_allocs)

	var cuc_mcontext_allocs *cgoAllocMap
	ref121f15cf.uc_mcontext, cuc_mcontext_allocs = x.UcMcontext.PassValue()
	allocs121f15cf.Borrow(cuc_mcontext_allocs)

	x.ref121f15cf = ref121f15cf
	x.allocs121f15cf = allocs121f15cf
	return ref121f15cf, allocs121f15cf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Ucontext) PassValue() (C.ucontext_t, *cgoAllocMap) {
	if x.ref121f15cf != nil {
		return *x.ref121f15cf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Ucontext) Deref() {
	if x.ref121f15cf == nil {
		return
	}
	x.UcOnstack = (int32)(x.ref121f15cf.uc_onstack)
	x.UcSigmask = (_DarwinSigset)(x.ref121f15cf.uc_sigmask)
	x.UcStack = *New_DarwinSigaltstackRef(unsafe.Pointer(&x.ref121f15cf.uc_stack))
	packS_DarwinUcontext(x.UcLink, x.ref121f15cf.uc_link)
	x.UcMcsize = (_DarwinSize)(x.ref121f15cf.uc_mcsize)
	x.UcMcontext = *New_DarwinMcontext64Ref(unsafe.Pointer(&x.ref121f15cf.uc_mcontext))
}

// allocStruct__DarwinX86Avx512State64Memory allocates memory for type C.struct___darwin_x86_avx512_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86Avx512State64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86Avx512State64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86Avx512State64Value = unsafe.Sizeof([1]C.struct___darwin_x86_avx512_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86Avx512State64) Ref() *C.struct___darwin_x86_avx512_state64 {
	if x == nil {
		return nil
	}
	return x.reff418433e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86Avx512State64) Free() {
	if x != nil && x.allocsf418433e != nil {
		x.allocsf418433e.(*cgoAllocMap).Free()
		x.reff418433e = nil
	}
}

// New_DarwinX86Avx512State64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86Avx512State64Ref(ref unsafe.Pointer) *_DarwinX86Avx512State64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86Avx512State64)
	obj.reff418433e = (*C.struct___darwin_x86_avx512_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86Avx512State64) PassRef() (*C.struct___darwin_x86_avx512_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff418433e != nil {
		return x.reff418433e, nil
	}
	memf418433e := allocStruct__DarwinX86Avx512State64Memory(1)
	reff418433e := (*C.struct___darwin_x86_avx512_state64)(memf418433e)
	allocsf418433e := new(cgoAllocMap)
	allocsf418433e.Add(memf418433e)

	var c__fpu_reserved_allocs *cgoAllocMap
	reff418433e.__fpu_reserved, c__fpu_reserved_allocs = *(*[2]C.int)(unsafe.Pointer(&x._FpuReserved)), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_reserved_allocs)

	var c__fpu_fcw_allocs *cgoAllocMap
	reff418433e.__fpu_fcw, c__fpu_fcw_allocs = x._FpuFcw.PassValue()
	allocsf418433e.Borrow(c__fpu_fcw_allocs)

	var c__fpu_fsw_allocs *cgoAllocMap
	reff418433e.__fpu_fsw, c__fpu_fsw_allocs = x._FpuFsw.PassValue()
	allocsf418433e.Borrow(c__fpu_fsw_allocs)

	var c__fpu_ftw_allocs *cgoAllocMap
	reff418433e.__fpu_ftw, c__fpu_ftw_allocs = (C.__uint8_t)(x._FpuFtw), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_ftw_allocs)

	var c__fpu_rsrv1_allocs *cgoAllocMap
	reff418433e.__fpu_rsrv1, c__fpu_rsrv1_allocs = (C.__uint8_t)(x._FpuRsrv1), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_rsrv1_allocs)

	var c__fpu_fop_allocs *cgoAllocMap
	reff418433e.__fpu_fop, c__fpu_fop_allocs = (C.__uint16_t)(x._FpuFop), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_fop_allocs)

	var c__fpu_ip_allocs *cgoAllocMap
	reff418433e.__fpu_ip, c__fpu_ip_allocs = (C.__uint32_t)(x._FpuIp), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_ip_allocs)

	var c__fpu_cs_allocs *cgoAllocMap
	reff418433e.__fpu_cs, c__fpu_cs_allocs = (C.__uint16_t)(x._FpuCs), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_cs_allocs)

	var c__fpu_rsrv2_allocs *cgoAllocMap
	reff418433e.__fpu_rsrv2, c__fpu_rsrv2_allocs = (C.__uint16_t)(x._FpuRsrv2), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_rsrv2_allocs)

	var c__fpu_dp_allocs *cgoAllocMap
	reff418433e.__fpu_dp, c__fpu_dp_allocs = (C.__uint32_t)(x._FpuDp), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_dp_allocs)

	var c__fpu_ds_allocs *cgoAllocMap
	reff418433e.__fpu_ds, c__fpu_ds_allocs = (C.__uint16_t)(x._FpuDs), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_ds_allocs)

	var c__fpu_rsrv3_allocs *cgoAllocMap
	reff418433e.__fpu_rsrv3, c__fpu_rsrv3_allocs = (C.__uint16_t)(x._FpuRsrv3), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_rsrv3_allocs)

	var c__fpu_mxcsr_allocs *cgoAllocMap
	reff418433e.__fpu_mxcsr, c__fpu_mxcsr_allocs = (C.__uint32_t)(x._FpuMxcsr), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_mxcsr_allocs)

	var c__fpu_mxcsrmask_allocs *cgoAllocMap
	reff418433e.__fpu_mxcsrmask, c__fpu_mxcsrmask_allocs = (C.__uint32_t)(x._FpuMxcsrmask), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_mxcsrmask_allocs)

	var c__fpu_stmm0_allocs *cgoAllocMap
	reff418433e.__fpu_stmm0, c__fpu_stmm0_allocs = x._FpuStmm0.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm0_allocs)

	var c__fpu_stmm1_allocs *cgoAllocMap
	reff418433e.__fpu_stmm1, c__fpu_stmm1_allocs = x._FpuStmm1.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm1_allocs)

	var c__fpu_stmm2_allocs *cgoAllocMap
	reff418433e.__fpu_stmm2, c__fpu_stmm2_allocs = x._FpuStmm2.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm2_allocs)

	var c__fpu_stmm3_allocs *cgoAllocMap
	reff418433e.__fpu_stmm3, c__fpu_stmm3_allocs = x._FpuStmm3.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm3_allocs)

	var c__fpu_stmm4_allocs *cgoAllocMap
	reff418433e.__fpu_stmm4, c__fpu_stmm4_allocs = x._FpuStmm4.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm4_allocs)

	var c__fpu_stmm5_allocs *cgoAllocMap
	reff418433e.__fpu_stmm5, c__fpu_stmm5_allocs = x._FpuStmm5.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm5_allocs)

	var c__fpu_stmm6_allocs *cgoAllocMap
	reff418433e.__fpu_stmm6, c__fpu_stmm6_allocs = x._FpuStmm6.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm6_allocs)

	var c__fpu_stmm7_allocs *cgoAllocMap
	reff418433e.__fpu_stmm7, c__fpu_stmm7_allocs = x._FpuStmm7.PassValue()
	allocsf418433e.Borrow(c__fpu_stmm7_allocs)

	var c__fpu_xmm0_allocs *cgoAllocMap
	reff418433e.__fpu_xmm0, c__fpu_xmm0_allocs = x._FpuXmm0.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm0_allocs)

	var c__fpu_xmm1_allocs *cgoAllocMap
	reff418433e.__fpu_xmm1, c__fpu_xmm1_allocs = x._FpuXmm1.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm1_allocs)

	var c__fpu_xmm2_allocs *cgoAllocMap
	reff418433e.__fpu_xmm2, c__fpu_xmm2_allocs = x._FpuXmm2.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm2_allocs)

	var c__fpu_xmm3_allocs *cgoAllocMap
	reff418433e.__fpu_xmm3, c__fpu_xmm3_allocs = x._FpuXmm3.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm3_allocs)

	var c__fpu_xmm4_allocs *cgoAllocMap
	reff418433e.__fpu_xmm4, c__fpu_xmm4_allocs = x._FpuXmm4.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm4_allocs)

	var c__fpu_xmm5_allocs *cgoAllocMap
	reff418433e.__fpu_xmm5, c__fpu_xmm5_allocs = x._FpuXmm5.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm5_allocs)

	var c__fpu_xmm6_allocs *cgoAllocMap
	reff418433e.__fpu_xmm6, c__fpu_xmm6_allocs = x._FpuXmm6.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm6_allocs)

	var c__fpu_xmm7_allocs *cgoAllocMap
	reff418433e.__fpu_xmm7, c__fpu_xmm7_allocs = x._FpuXmm7.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm7_allocs)

	var c__fpu_xmm8_allocs *cgoAllocMap
	reff418433e.__fpu_xmm8, c__fpu_xmm8_allocs = x._FpuXmm8.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm8_allocs)

	var c__fpu_xmm9_allocs *cgoAllocMap
	reff418433e.__fpu_xmm9, c__fpu_xmm9_allocs = x._FpuXmm9.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm9_allocs)

	var c__fpu_xmm10_allocs *cgoAllocMap
	reff418433e.__fpu_xmm10, c__fpu_xmm10_allocs = x._FpuXmm10.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm10_allocs)

	var c__fpu_xmm11_allocs *cgoAllocMap
	reff418433e.__fpu_xmm11, c__fpu_xmm11_allocs = x._FpuXmm11.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm11_allocs)

	var c__fpu_xmm12_allocs *cgoAllocMap
	reff418433e.__fpu_xmm12, c__fpu_xmm12_allocs = x._FpuXmm12.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm12_allocs)

	var c__fpu_xmm13_allocs *cgoAllocMap
	reff418433e.__fpu_xmm13, c__fpu_xmm13_allocs = x._FpuXmm13.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm13_allocs)

	var c__fpu_xmm14_allocs *cgoAllocMap
	reff418433e.__fpu_xmm14, c__fpu_xmm14_allocs = x._FpuXmm14.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm14_allocs)

	var c__fpu_xmm15_allocs *cgoAllocMap
	reff418433e.__fpu_xmm15, c__fpu_xmm15_allocs = x._FpuXmm15.PassValue()
	allocsf418433e.Borrow(c__fpu_xmm15_allocs)

	var c__fpu_rsrv4_allocs *cgoAllocMap
	reff418433e.__fpu_rsrv4, c__fpu_rsrv4_allocs = *(*[96]C.char)(unsafe.Pointer(&x._FpuRsrv4)), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_rsrv4_allocs)

	var c__fpu_reserved1_allocs *cgoAllocMap
	reff418433e.__fpu_reserved1, c__fpu_reserved1_allocs = (C.int)(x._FpuReserved1), cgoAllocsUnknown
	allocsf418433e.Borrow(c__fpu_reserved1_allocs)

	var c__avx_reserved1_allocs *cgoAllocMap
	reff418433e.__avx_reserved1, c__avx_reserved1_allocs = *(*[64]C.char)(unsafe.Pointer(&x._AvxReserved1)), cgoAllocsUnknown
	allocsf418433e.Borrow(c__avx_reserved1_allocs)

	var c__fpu_ymmh0_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh0, c__fpu_ymmh0_allocs = x._FpuYmmh0.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh0_allocs)

	var c__fpu_ymmh1_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh1, c__fpu_ymmh1_allocs = x._FpuYmmh1.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh1_allocs)

	var c__fpu_ymmh2_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh2, c__fpu_ymmh2_allocs = x._FpuYmmh2.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh2_allocs)

	var c__fpu_ymmh3_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh3, c__fpu_ymmh3_allocs = x._FpuYmmh3.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh3_allocs)

	var c__fpu_ymmh4_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh4, c__fpu_ymmh4_allocs = x._FpuYmmh4.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh4_allocs)

	var c__fpu_ymmh5_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh5, c__fpu_ymmh5_allocs = x._FpuYmmh5.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh5_allocs)

	var c__fpu_ymmh6_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh6, c__fpu_ymmh6_allocs = x._FpuYmmh6.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh6_allocs)

	var c__fpu_ymmh7_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh7, c__fpu_ymmh7_allocs = x._FpuYmmh7.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh7_allocs)

	var c__fpu_ymmh8_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh8, c__fpu_ymmh8_allocs = x._FpuYmmh8.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh8_allocs)

	var c__fpu_ymmh9_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh9, c__fpu_ymmh9_allocs = x._FpuYmmh9.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh9_allocs)

	var c__fpu_ymmh10_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh10, c__fpu_ymmh10_allocs = x._FpuYmmh10.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh10_allocs)

	var c__fpu_ymmh11_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh11, c__fpu_ymmh11_allocs = x._FpuYmmh11.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh11_allocs)

	var c__fpu_ymmh12_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh12, c__fpu_ymmh12_allocs = x._FpuYmmh12.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh12_allocs)

	var c__fpu_ymmh13_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh13, c__fpu_ymmh13_allocs = x._FpuYmmh13.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh13_allocs)

	var c__fpu_ymmh14_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh14, c__fpu_ymmh14_allocs = x._FpuYmmh14.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh14_allocs)

	var c__fpu_ymmh15_allocs *cgoAllocMap
	reff418433e.__fpu_ymmh15, c__fpu_ymmh15_allocs = x._FpuYmmh15.PassValue()
	allocsf418433e.Borrow(c__fpu_ymmh15_allocs)

	var c__fpu_k0_allocs *cgoAllocMap
	reff418433e.__fpu_k0, c__fpu_k0_allocs = x._FpuK0.PassValue()
	allocsf418433e.Borrow(c__fpu_k0_allocs)

	var c__fpu_k1_allocs *cgoAllocMap
	reff418433e.__fpu_k1, c__fpu_k1_allocs = x._FpuK1.PassValue()
	allocsf418433e.Borrow(c__fpu_k1_allocs)

	var c__fpu_k2_allocs *cgoAllocMap
	reff418433e.__fpu_k2, c__fpu_k2_allocs = x._FpuK2.PassValue()
	allocsf418433e.Borrow(c__fpu_k2_allocs)

	var c__fpu_k3_allocs *cgoAllocMap
	reff418433e.__fpu_k3, c__fpu_k3_allocs = x._FpuK3.PassValue()
	allocsf418433e.Borrow(c__fpu_k3_allocs)

	var c__fpu_k4_allocs *cgoAllocMap
	reff418433e.__fpu_k4, c__fpu_k4_allocs = x._FpuK4.PassValue()
	allocsf418433e.Borrow(c__fpu_k4_allocs)

	var c__fpu_k5_allocs *cgoAllocMap
	reff418433e.__fpu_k5, c__fpu_k5_allocs = x._FpuK5.PassValue()
	allocsf418433e.Borrow(c__fpu_k5_allocs)

	var c__fpu_k6_allocs *cgoAllocMap
	reff418433e.__fpu_k6, c__fpu_k6_allocs = x._FpuK6.PassValue()
	allocsf418433e.Borrow(c__fpu_k6_allocs)

	var c__fpu_k7_allocs *cgoAllocMap
	reff418433e.__fpu_k7, c__fpu_k7_allocs = x._FpuK7.PassValue()
	allocsf418433e.Borrow(c__fpu_k7_allocs)

	var c__fpu_zmmh0_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh0, c__fpu_zmmh0_allocs = x._FpuZmmh0.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh0_allocs)

	var c__fpu_zmmh1_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh1, c__fpu_zmmh1_allocs = x._FpuZmmh1.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh1_allocs)

	var c__fpu_zmmh2_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh2, c__fpu_zmmh2_allocs = x._FpuZmmh2.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh2_allocs)

	var c__fpu_zmmh3_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh3, c__fpu_zmmh3_allocs = x._FpuZmmh3.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh3_allocs)

	var c__fpu_zmmh4_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh4, c__fpu_zmmh4_allocs = x._FpuZmmh4.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh4_allocs)

	var c__fpu_zmmh5_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh5, c__fpu_zmmh5_allocs = x._FpuZmmh5.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh5_allocs)

	var c__fpu_zmmh6_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh6, c__fpu_zmmh6_allocs = x._FpuZmmh6.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh6_allocs)

	var c__fpu_zmmh7_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh7, c__fpu_zmmh7_allocs = x._FpuZmmh7.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh7_allocs)

	var c__fpu_zmmh8_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh8, c__fpu_zmmh8_allocs = x._FpuZmmh8.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh8_allocs)

	var c__fpu_zmmh9_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh9, c__fpu_zmmh9_allocs = x._FpuZmmh9.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh9_allocs)

	var c__fpu_zmmh10_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh10, c__fpu_zmmh10_allocs = x._FpuZmmh10.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh10_allocs)

	var c__fpu_zmmh11_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh11, c__fpu_zmmh11_allocs = x._FpuZmmh11.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh11_allocs)

	var c__fpu_zmmh12_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh12, c__fpu_zmmh12_allocs = x._FpuZmmh12.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh12_allocs)

	var c__fpu_zmmh13_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh13, c__fpu_zmmh13_allocs = x._FpuZmmh13.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh13_allocs)

	var c__fpu_zmmh14_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh14, c__fpu_zmmh14_allocs = x._FpuZmmh14.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh14_allocs)

	var c__fpu_zmmh15_allocs *cgoAllocMap
	reff418433e.__fpu_zmmh15, c__fpu_zmmh15_allocs = x._FpuZmmh15.PassValue()
	allocsf418433e.Borrow(c__fpu_zmmh15_allocs)

	var c__fpu_zmm16_allocs *cgoAllocMap
	reff418433e.__fpu_zmm16, c__fpu_zmm16_allocs = x._FpuZmm16.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm16_allocs)

	var c__fpu_zmm17_allocs *cgoAllocMap
	reff418433e.__fpu_zmm17, c__fpu_zmm17_allocs = x._FpuZmm17.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm17_allocs)

	var c__fpu_zmm18_allocs *cgoAllocMap
	reff418433e.__fpu_zmm18, c__fpu_zmm18_allocs = x._FpuZmm18.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm18_allocs)

	var c__fpu_zmm19_allocs *cgoAllocMap
	reff418433e.__fpu_zmm19, c__fpu_zmm19_allocs = x._FpuZmm19.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm19_allocs)

	var c__fpu_zmm20_allocs *cgoAllocMap
	reff418433e.__fpu_zmm20, c__fpu_zmm20_allocs = x._FpuZmm20.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm20_allocs)

	var c__fpu_zmm21_allocs *cgoAllocMap
	reff418433e.__fpu_zmm21, c__fpu_zmm21_allocs = x._FpuZmm21.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm21_allocs)

	var c__fpu_zmm22_allocs *cgoAllocMap
	reff418433e.__fpu_zmm22, c__fpu_zmm22_allocs = x._FpuZmm22.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm22_allocs)

	var c__fpu_zmm23_allocs *cgoAllocMap
	reff418433e.__fpu_zmm23, c__fpu_zmm23_allocs = x._FpuZmm23.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm23_allocs)

	var c__fpu_zmm24_allocs *cgoAllocMap
	reff418433e.__fpu_zmm24, c__fpu_zmm24_allocs = x._FpuZmm24.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm24_allocs)

	var c__fpu_zmm25_allocs *cgoAllocMap
	reff418433e.__fpu_zmm25, c__fpu_zmm25_allocs = x._FpuZmm25.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm25_allocs)

	var c__fpu_zmm26_allocs *cgoAllocMap
	reff418433e.__fpu_zmm26, c__fpu_zmm26_allocs = x._FpuZmm26.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm26_allocs)

	var c__fpu_zmm27_allocs *cgoAllocMap
	reff418433e.__fpu_zmm27, c__fpu_zmm27_allocs = x._FpuZmm27.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm27_allocs)

	var c__fpu_zmm28_allocs *cgoAllocMap
	reff418433e.__fpu_zmm28, c__fpu_zmm28_allocs = x._FpuZmm28.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm28_allocs)

	var c__fpu_zmm29_allocs *cgoAllocMap
	reff418433e.__fpu_zmm29, c__fpu_zmm29_allocs = x._FpuZmm29.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm29_allocs)

	var c__fpu_zmm30_allocs *cgoAllocMap
	reff418433e.__fpu_zmm30, c__fpu_zmm30_allocs = x._FpuZmm30.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm30_allocs)

	var c__fpu_zmm31_allocs *cgoAllocMap
	reff418433e.__fpu_zmm31, c__fpu_zmm31_allocs = x._FpuZmm31.PassValue()
	allocsf418433e.Borrow(c__fpu_zmm31_allocs)

	x.reff418433e = reff418433e
	x.allocsf418433e = allocsf418433e
	return reff418433e, allocsf418433e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86Avx512State64) PassValue() (C.struct___darwin_x86_avx512_state64, *cgoAllocMap) {
	if x.reff418433e != nil {
		return *x.reff418433e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86Avx512State64) Deref() {
	if x.reff418433e == nil {
		return
	}
	x._FpuReserved = *(*[2]int32)(unsafe.Pointer(&x.reff418433e.__fpu_reserved))
	x._FpuFcw = *New_DarwinFpControlRef(unsafe.Pointer(&x.reff418433e.__fpu_fcw))
	x._FpuFsw = *New_DarwinFpStatusRef(unsafe.Pointer(&x.reff418433e.__fpu_fsw))
	x._FpuFtw = (byte)(x.reff418433e.__fpu_ftw)
	x._FpuRsrv1 = (byte)(x.reff418433e.__fpu_rsrv1)
	x._FpuFop = (uint16)(x.reff418433e.__fpu_fop)
	x._FpuIp = (uint32)(x.reff418433e.__fpu_ip)
	x._FpuCs = (uint16)(x.reff418433e.__fpu_cs)
	x._FpuRsrv2 = (uint16)(x.reff418433e.__fpu_rsrv2)
	x._FpuDp = (uint32)(x.reff418433e.__fpu_dp)
	x._FpuDs = (uint16)(x.reff418433e.__fpu_ds)
	x._FpuRsrv3 = (uint16)(x.reff418433e.__fpu_rsrv3)
	x._FpuMxcsr = (uint32)(x.reff418433e.__fpu_mxcsr)
	x._FpuMxcsrmask = (uint32)(x.reff418433e.__fpu_mxcsrmask)
	x._FpuStmm0 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm0))
	x._FpuStmm1 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm1))
	x._FpuStmm2 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm2))
	x._FpuStmm3 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm3))
	x._FpuStmm4 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm4))
	x._FpuStmm5 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm5))
	x._FpuStmm6 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm6))
	x._FpuStmm7 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.reff418433e.__fpu_stmm7))
	x._FpuXmm0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm0))
	x._FpuXmm1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm1))
	x._FpuXmm2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm2))
	x._FpuXmm3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm3))
	x._FpuXmm4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm4))
	x._FpuXmm5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm5))
	x._FpuXmm6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm6))
	x._FpuXmm7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm7))
	x._FpuXmm8 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm8))
	x._FpuXmm9 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm9))
	x._FpuXmm10 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm10))
	x._FpuXmm11 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm11))
	x._FpuXmm12 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm12))
	x._FpuXmm13 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm13))
	x._FpuXmm14 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm14))
	x._FpuXmm15 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_xmm15))
	x._FpuRsrv4 = *(*[96]byte)(unsafe.Pointer(&x.reff418433e.__fpu_rsrv4))
	x._FpuReserved1 = (int32)(x.reff418433e.__fpu_reserved1)
	x._AvxReserved1 = *(*[64]byte)(unsafe.Pointer(&x.reff418433e.__avx_reserved1))
	x._FpuYmmh0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh0))
	x._FpuYmmh1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh1))
	x._FpuYmmh2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh2))
	x._FpuYmmh3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh3))
	x._FpuYmmh4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh4))
	x._FpuYmmh5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh5))
	x._FpuYmmh6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh6))
	x._FpuYmmh7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh7))
	x._FpuYmmh8 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh8))
	x._FpuYmmh9 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh9))
	x._FpuYmmh10 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh10))
	x._FpuYmmh11 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh11))
	x._FpuYmmh12 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh12))
	x._FpuYmmh13 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh13))
	x._FpuYmmh14 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh14))
	x._FpuYmmh15 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_ymmh15))
	x._FpuK0 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k0))
	x._FpuK1 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k1))
	x._FpuK2 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k2))
	x._FpuK3 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k3))
	x._FpuK4 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k4))
	x._FpuK5 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k5))
	x._FpuK6 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k6))
	x._FpuK7 = *New_DarwinOpmaskRegRef(unsafe.Pointer(&x.reff418433e.__fpu_k7))
	x._FpuZmmh0 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh0))
	x._FpuZmmh1 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh1))
	x._FpuZmmh2 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh2))
	x._FpuZmmh3 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh3))
	x._FpuZmmh4 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh4))
	x._FpuZmmh5 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh5))
	x._FpuZmmh6 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh6))
	x._FpuZmmh7 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh7))
	x._FpuZmmh8 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh8))
	x._FpuZmmh9 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh9))
	x._FpuZmmh10 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh10))
	x._FpuZmmh11 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh11))
	x._FpuZmmh12 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh12))
	x._FpuZmmh13 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh13))
	x._FpuZmmh14 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh14))
	x._FpuZmmh15 = *New_DarwinYmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmmh15))
	x._FpuZmm16 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm16))
	x._FpuZmm17 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm17))
	x._FpuZmm18 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm18))
	x._FpuZmm19 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm19))
	x._FpuZmm20 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm20))
	x._FpuZmm21 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm21))
	x._FpuZmm22 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm22))
	x._FpuZmm23 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm23))
	x._FpuZmm24 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm24))
	x._FpuZmm25 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm25))
	x._FpuZmm26 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm26))
	x._FpuZmm27 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm27))
	x._FpuZmm28 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm28))
	x._FpuZmm29 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm29))
	x._FpuZmm30 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm30))
	x._FpuZmm31 = *New_DarwinZmmRegRef(unsafe.Pointer(&x.reff418433e.__fpu_zmm31))
}

// allocStruct__DarwinX86AvxState64Memory allocates memory for type C.struct___darwin_x86_avx_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86AvxState64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86AvxState64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86AvxState64Value = unsafe.Sizeof([1]C.struct___darwin_x86_avx_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86AvxState64) Ref() *C.struct___darwin_x86_avx_state64 {
	if x == nil {
		return nil
	}
	return x.ref1de1744d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86AvxState64) Free() {
	if x != nil && x.allocs1de1744d != nil {
		x.allocs1de1744d.(*cgoAllocMap).Free()
		x.ref1de1744d = nil
	}
}

// New_DarwinX86AvxState64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86AvxState64Ref(ref unsafe.Pointer) *_DarwinX86AvxState64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86AvxState64)
	obj.ref1de1744d = (*C.struct___darwin_x86_avx_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86AvxState64) PassRef() (*C.struct___darwin_x86_avx_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1de1744d != nil {
		return x.ref1de1744d, nil
	}
	mem1de1744d := allocStruct__DarwinX86AvxState64Memory(1)
	ref1de1744d := (*C.struct___darwin_x86_avx_state64)(mem1de1744d)
	allocs1de1744d := new(cgoAllocMap)
	allocs1de1744d.Add(mem1de1744d)

	var c__fpu_reserved_allocs *cgoAllocMap
	ref1de1744d.__fpu_reserved, c__fpu_reserved_allocs = *(*[2]C.int)(unsafe.Pointer(&x._FpuReserved)), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_reserved_allocs)

	var c__fpu_fcw_allocs *cgoAllocMap
	ref1de1744d.__fpu_fcw, c__fpu_fcw_allocs = x._FpuFcw.PassValue()
	allocs1de1744d.Borrow(c__fpu_fcw_allocs)

	var c__fpu_fsw_allocs *cgoAllocMap
	ref1de1744d.__fpu_fsw, c__fpu_fsw_allocs = x._FpuFsw.PassValue()
	allocs1de1744d.Borrow(c__fpu_fsw_allocs)

	var c__fpu_ftw_allocs *cgoAllocMap
	ref1de1744d.__fpu_ftw, c__fpu_ftw_allocs = (C.__uint8_t)(x._FpuFtw), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_ftw_allocs)

	var c__fpu_rsrv1_allocs *cgoAllocMap
	ref1de1744d.__fpu_rsrv1, c__fpu_rsrv1_allocs = (C.__uint8_t)(x._FpuRsrv1), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_rsrv1_allocs)

	var c__fpu_fop_allocs *cgoAllocMap
	ref1de1744d.__fpu_fop, c__fpu_fop_allocs = (C.__uint16_t)(x._FpuFop), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_fop_allocs)

	var c__fpu_ip_allocs *cgoAllocMap
	ref1de1744d.__fpu_ip, c__fpu_ip_allocs = (C.__uint32_t)(x._FpuIp), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_ip_allocs)

	var c__fpu_cs_allocs *cgoAllocMap
	ref1de1744d.__fpu_cs, c__fpu_cs_allocs = (C.__uint16_t)(x._FpuCs), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_cs_allocs)

	var c__fpu_rsrv2_allocs *cgoAllocMap
	ref1de1744d.__fpu_rsrv2, c__fpu_rsrv2_allocs = (C.__uint16_t)(x._FpuRsrv2), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_rsrv2_allocs)

	var c__fpu_dp_allocs *cgoAllocMap
	ref1de1744d.__fpu_dp, c__fpu_dp_allocs = (C.__uint32_t)(x._FpuDp), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_dp_allocs)

	var c__fpu_ds_allocs *cgoAllocMap
	ref1de1744d.__fpu_ds, c__fpu_ds_allocs = (C.__uint16_t)(x._FpuDs), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_ds_allocs)

	var c__fpu_rsrv3_allocs *cgoAllocMap
	ref1de1744d.__fpu_rsrv3, c__fpu_rsrv3_allocs = (C.__uint16_t)(x._FpuRsrv3), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_rsrv3_allocs)

	var c__fpu_mxcsr_allocs *cgoAllocMap
	ref1de1744d.__fpu_mxcsr, c__fpu_mxcsr_allocs = (C.__uint32_t)(x._FpuMxcsr), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_mxcsr_allocs)

	var c__fpu_mxcsrmask_allocs *cgoAllocMap
	ref1de1744d.__fpu_mxcsrmask, c__fpu_mxcsrmask_allocs = (C.__uint32_t)(x._FpuMxcsrmask), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_mxcsrmask_allocs)

	var c__fpu_stmm0_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm0, c__fpu_stmm0_allocs = x._FpuStmm0.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm0_allocs)

	var c__fpu_stmm1_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm1, c__fpu_stmm1_allocs = x._FpuStmm1.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm1_allocs)

	var c__fpu_stmm2_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm2, c__fpu_stmm2_allocs = x._FpuStmm2.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm2_allocs)

	var c__fpu_stmm3_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm3, c__fpu_stmm3_allocs = x._FpuStmm3.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm3_allocs)

	var c__fpu_stmm4_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm4, c__fpu_stmm4_allocs = x._FpuStmm4.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm4_allocs)

	var c__fpu_stmm5_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm5, c__fpu_stmm5_allocs = x._FpuStmm5.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm5_allocs)

	var c__fpu_stmm6_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm6, c__fpu_stmm6_allocs = x._FpuStmm6.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm6_allocs)

	var c__fpu_stmm7_allocs *cgoAllocMap
	ref1de1744d.__fpu_stmm7, c__fpu_stmm7_allocs = x._FpuStmm7.PassValue()
	allocs1de1744d.Borrow(c__fpu_stmm7_allocs)

	var c__fpu_xmm0_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm0, c__fpu_xmm0_allocs = x._FpuXmm0.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm0_allocs)

	var c__fpu_xmm1_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm1, c__fpu_xmm1_allocs = x._FpuXmm1.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm1_allocs)

	var c__fpu_xmm2_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm2, c__fpu_xmm2_allocs = x._FpuXmm2.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm2_allocs)

	var c__fpu_xmm3_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm3, c__fpu_xmm3_allocs = x._FpuXmm3.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm3_allocs)

	var c__fpu_xmm4_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm4, c__fpu_xmm4_allocs = x._FpuXmm4.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm4_allocs)

	var c__fpu_xmm5_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm5, c__fpu_xmm5_allocs = x._FpuXmm5.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm5_allocs)

	var c__fpu_xmm6_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm6, c__fpu_xmm6_allocs = x._FpuXmm6.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm6_allocs)

	var c__fpu_xmm7_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm7, c__fpu_xmm7_allocs = x._FpuXmm7.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm7_allocs)

	var c__fpu_xmm8_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm8, c__fpu_xmm8_allocs = x._FpuXmm8.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm8_allocs)

	var c__fpu_xmm9_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm9, c__fpu_xmm9_allocs = x._FpuXmm9.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm9_allocs)

	var c__fpu_xmm10_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm10, c__fpu_xmm10_allocs = x._FpuXmm10.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm10_allocs)

	var c__fpu_xmm11_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm11, c__fpu_xmm11_allocs = x._FpuXmm11.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm11_allocs)

	var c__fpu_xmm12_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm12, c__fpu_xmm12_allocs = x._FpuXmm12.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm12_allocs)

	var c__fpu_xmm13_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm13, c__fpu_xmm13_allocs = x._FpuXmm13.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm13_allocs)

	var c__fpu_xmm14_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm14, c__fpu_xmm14_allocs = x._FpuXmm14.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm14_allocs)

	var c__fpu_xmm15_allocs *cgoAllocMap
	ref1de1744d.__fpu_xmm15, c__fpu_xmm15_allocs = x._FpuXmm15.PassValue()
	allocs1de1744d.Borrow(c__fpu_xmm15_allocs)

	var c__fpu_rsrv4_allocs *cgoAllocMap
	ref1de1744d.__fpu_rsrv4, c__fpu_rsrv4_allocs = *(*[96]C.char)(unsafe.Pointer(&x._FpuRsrv4)), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_rsrv4_allocs)

	var c__fpu_reserved1_allocs *cgoAllocMap
	ref1de1744d.__fpu_reserved1, c__fpu_reserved1_allocs = (C.int)(x._FpuReserved1), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__fpu_reserved1_allocs)

	var c__avx_reserved1_allocs *cgoAllocMap
	ref1de1744d.__avx_reserved1, c__avx_reserved1_allocs = *(*[64]C.char)(unsafe.Pointer(&x._AvxReserved1)), cgoAllocsUnknown
	allocs1de1744d.Borrow(c__avx_reserved1_allocs)

	var c__fpu_ymmh0_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh0, c__fpu_ymmh0_allocs = x._FpuYmmh0.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh0_allocs)

	var c__fpu_ymmh1_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh1, c__fpu_ymmh1_allocs = x._FpuYmmh1.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh1_allocs)

	var c__fpu_ymmh2_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh2, c__fpu_ymmh2_allocs = x._FpuYmmh2.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh2_allocs)

	var c__fpu_ymmh3_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh3, c__fpu_ymmh3_allocs = x._FpuYmmh3.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh3_allocs)

	var c__fpu_ymmh4_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh4, c__fpu_ymmh4_allocs = x._FpuYmmh4.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh4_allocs)

	var c__fpu_ymmh5_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh5, c__fpu_ymmh5_allocs = x._FpuYmmh5.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh5_allocs)

	var c__fpu_ymmh6_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh6, c__fpu_ymmh6_allocs = x._FpuYmmh6.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh6_allocs)

	var c__fpu_ymmh7_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh7, c__fpu_ymmh7_allocs = x._FpuYmmh7.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh7_allocs)

	var c__fpu_ymmh8_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh8, c__fpu_ymmh8_allocs = x._FpuYmmh8.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh8_allocs)

	var c__fpu_ymmh9_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh9, c__fpu_ymmh9_allocs = x._FpuYmmh9.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh9_allocs)

	var c__fpu_ymmh10_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh10, c__fpu_ymmh10_allocs = x._FpuYmmh10.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh10_allocs)

	var c__fpu_ymmh11_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh11, c__fpu_ymmh11_allocs = x._FpuYmmh11.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh11_allocs)

	var c__fpu_ymmh12_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh12, c__fpu_ymmh12_allocs = x._FpuYmmh12.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh12_allocs)

	var c__fpu_ymmh13_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh13, c__fpu_ymmh13_allocs = x._FpuYmmh13.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh13_allocs)

	var c__fpu_ymmh14_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh14, c__fpu_ymmh14_allocs = x._FpuYmmh14.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh14_allocs)

	var c__fpu_ymmh15_allocs *cgoAllocMap
	ref1de1744d.__fpu_ymmh15, c__fpu_ymmh15_allocs = x._FpuYmmh15.PassValue()
	allocs1de1744d.Borrow(c__fpu_ymmh15_allocs)

	x.ref1de1744d = ref1de1744d
	x.allocs1de1744d = allocs1de1744d
	return ref1de1744d, allocs1de1744d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86AvxState64) PassValue() (C.struct___darwin_x86_avx_state64, *cgoAllocMap) {
	if x.ref1de1744d != nil {
		return *x.ref1de1744d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86AvxState64) Deref() {
	if x.ref1de1744d == nil {
		return
	}
	x._FpuReserved = *(*[2]int32)(unsafe.Pointer(&x.ref1de1744d.__fpu_reserved))
	x._FpuFcw = *New_DarwinFpControlRef(unsafe.Pointer(&x.ref1de1744d.__fpu_fcw))
	x._FpuFsw = *New_DarwinFpStatusRef(unsafe.Pointer(&x.ref1de1744d.__fpu_fsw))
	x._FpuFtw = (byte)(x.ref1de1744d.__fpu_ftw)
	x._FpuRsrv1 = (byte)(x.ref1de1744d.__fpu_rsrv1)
	x._FpuFop = (uint16)(x.ref1de1744d.__fpu_fop)
	x._FpuIp = (uint32)(x.ref1de1744d.__fpu_ip)
	x._FpuCs = (uint16)(x.ref1de1744d.__fpu_cs)
	x._FpuRsrv2 = (uint16)(x.ref1de1744d.__fpu_rsrv2)
	x._FpuDp = (uint32)(x.ref1de1744d.__fpu_dp)
	x._FpuDs = (uint16)(x.ref1de1744d.__fpu_ds)
	x._FpuRsrv3 = (uint16)(x.ref1de1744d.__fpu_rsrv3)
	x._FpuMxcsr = (uint32)(x.ref1de1744d.__fpu_mxcsr)
	x._FpuMxcsrmask = (uint32)(x.ref1de1744d.__fpu_mxcsrmask)
	x._FpuStmm0 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm0))
	x._FpuStmm1 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm1))
	x._FpuStmm2 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm2))
	x._FpuStmm3 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm3))
	x._FpuStmm4 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm4))
	x._FpuStmm5 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm5))
	x._FpuStmm6 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm6))
	x._FpuStmm7 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_stmm7))
	x._FpuXmm0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm0))
	x._FpuXmm1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm1))
	x._FpuXmm2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm2))
	x._FpuXmm3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm3))
	x._FpuXmm4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm4))
	x._FpuXmm5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm5))
	x._FpuXmm6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm6))
	x._FpuXmm7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm7))
	x._FpuXmm8 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm8))
	x._FpuXmm9 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm9))
	x._FpuXmm10 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm10))
	x._FpuXmm11 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm11))
	x._FpuXmm12 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm12))
	x._FpuXmm13 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm13))
	x._FpuXmm14 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm14))
	x._FpuXmm15 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_xmm15))
	x._FpuRsrv4 = *(*[96]byte)(unsafe.Pointer(&x.ref1de1744d.__fpu_rsrv4))
	x._FpuReserved1 = (int32)(x.ref1de1744d.__fpu_reserved1)
	x._AvxReserved1 = *(*[64]byte)(unsafe.Pointer(&x.ref1de1744d.__avx_reserved1))
	x._FpuYmmh0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh0))
	x._FpuYmmh1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh1))
	x._FpuYmmh2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh2))
	x._FpuYmmh3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh3))
	x._FpuYmmh4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh4))
	x._FpuYmmh5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh5))
	x._FpuYmmh6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh6))
	x._FpuYmmh7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh7))
	x._FpuYmmh8 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh8))
	x._FpuYmmh9 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh9))
	x._FpuYmmh10 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh10))
	x._FpuYmmh11 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh11))
	x._FpuYmmh12 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh12))
	x._FpuYmmh13 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh13))
	x._FpuYmmh14 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh14))
	x._FpuYmmh15 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref1de1744d.__fpu_ymmh15))
}

// allocStruct__DarwinX86CpmuState64Memory allocates memory for type C.struct___darwin_x86_cpmu_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86CpmuState64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86CpmuState64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86CpmuState64Value = unsafe.Sizeof([1]C.struct___darwin_x86_cpmu_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86CpmuState64) Ref() *C.struct___darwin_x86_cpmu_state64 {
	if x == nil {
		return nil
	}
	return x.refd1cd1f0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86CpmuState64) Free() {
	if x != nil && x.allocsd1cd1f0 != nil {
		x.allocsd1cd1f0.(*cgoAllocMap).Free()
		x.refd1cd1f0 = nil
	}
}

// New_DarwinX86CpmuState64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86CpmuState64Ref(ref unsafe.Pointer) *_DarwinX86CpmuState64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86CpmuState64)
	obj.refd1cd1f0 = (*C.struct___darwin_x86_cpmu_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86CpmuState64) PassRef() (*C.struct___darwin_x86_cpmu_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1cd1f0 != nil {
		return x.refd1cd1f0, nil
	}
	memd1cd1f0 := allocStruct__DarwinX86CpmuState64Memory(1)
	refd1cd1f0 := (*C.struct___darwin_x86_cpmu_state64)(memd1cd1f0)
	allocsd1cd1f0 := new(cgoAllocMap)
	allocsd1cd1f0.Add(memd1cd1f0)

	var c__ctrs_allocs *cgoAllocMap
	refd1cd1f0.__ctrs, c__ctrs_allocs = *(*[16]C.__uint64_t)(unsafe.Pointer(&x._Ctrs)), cgoAllocsUnknown
	allocsd1cd1f0.Borrow(c__ctrs_allocs)

	x.refd1cd1f0 = refd1cd1f0
	x.allocsd1cd1f0 = allocsd1cd1f0
	return refd1cd1f0, allocsd1cd1f0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86CpmuState64) PassValue() (C.struct___darwin_x86_cpmu_state64, *cgoAllocMap) {
	if x.refd1cd1f0 != nil {
		return *x.refd1cd1f0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86CpmuState64) Deref() {
	if x.refd1cd1f0 == nil {
		return
	}
	x._Ctrs = *(*[16]uint64)(unsafe.Pointer(&x.refd1cd1f0.__ctrs))
}

// allocStruct__DarwinX86DebugState32Memory allocates memory for type C.struct___darwin_x86_debug_state32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86DebugState32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86DebugState32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86DebugState32Value = unsafe.Sizeof([1]C.struct___darwin_x86_debug_state32{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86DebugState32) Ref() *C.struct___darwin_x86_debug_state32 {
	if x == nil {
		return nil
	}
	return x.ref11c7aee1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86DebugState32) Free() {
	if x != nil && x.allocs11c7aee1 != nil {
		x.allocs11c7aee1.(*cgoAllocMap).Free()
		x.ref11c7aee1 = nil
	}
}

// New_DarwinX86DebugState32Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86DebugState32Ref(ref unsafe.Pointer) *_DarwinX86DebugState32 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86DebugState32)
	obj.ref11c7aee1 = (*C.struct___darwin_x86_debug_state32)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86DebugState32) PassRef() (*C.struct___darwin_x86_debug_state32, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11c7aee1 != nil {
		return x.ref11c7aee1, nil
	}
	mem11c7aee1 := allocStruct__DarwinX86DebugState32Memory(1)
	ref11c7aee1 := (*C.struct___darwin_x86_debug_state32)(mem11c7aee1)
	allocs11c7aee1 := new(cgoAllocMap)
	allocs11c7aee1.Add(mem11c7aee1)

	var c__dr0_allocs *cgoAllocMap
	ref11c7aee1.__dr0, c__dr0_allocs = (C.uint)(x._Dr0), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr0_allocs)

	var c__dr1_allocs *cgoAllocMap
	ref11c7aee1.__dr1, c__dr1_allocs = (C.uint)(x._Dr1), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr1_allocs)

	var c__dr2_allocs *cgoAllocMap
	ref11c7aee1.__dr2, c__dr2_allocs = (C.uint)(x._Dr2), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr2_allocs)

	var c__dr3_allocs *cgoAllocMap
	ref11c7aee1.__dr3, c__dr3_allocs = (C.uint)(x._Dr3), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr3_allocs)

	var c__dr4_allocs *cgoAllocMap
	ref11c7aee1.__dr4, c__dr4_allocs = (C.uint)(x._Dr4), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr4_allocs)

	var c__dr5_allocs *cgoAllocMap
	ref11c7aee1.__dr5, c__dr5_allocs = (C.uint)(x._Dr5), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr5_allocs)

	var c__dr6_allocs *cgoAllocMap
	ref11c7aee1.__dr6, c__dr6_allocs = (C.uint)(x._Dr6), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr6_allocs)

	var c__dr7_allocs *cgoAllocMap
	ref11c7aee1.__dr7, c__dr7_allocs = (C.uint)(x._Dr7), cgoAllocsUnknown
	allocs11c7aee1.Borrow(c__dr7_allocs)

	x.ref11c7aee1 = ref11c7aee1
	x.allocs11c7aee1 = allocs11c7aee1
	return ref11c7aee1, allocs11c7aee1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86DebugState32) PassValue() (C.struct___darwin_x86_debug_state32, *cgoAllocMap) {
	if x.ref11c7aee1 != nil {
		return *x.ref11c7aee1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86DebugState32) Deref() {
	if x.ref11c7aee1 == nil {
		return
	}
	x._Dr0 = (uint32)(x.ref11c7aee1.__dr0)
	x._Dr1 = (uint32)(x.ref11c7aee1.__dr1)
	x._Dr2 = (uint32)(x.ref11c7aee1.__dr2)
	x._Dr3 = (uint32)(x.ref11c7aee1.__dr3)
	x._Dr4 = (uint32)(x.ref11c7aee1.__dr4)
	x._Dr5 = (uint32)(x.ref11c7aee1.__dr5)
	x._Dr6 = (uint32)(x.ref11c7aee1.__dr6)
	x._Dr7 = (uint32)(x.ref11c7aee1.__dr7)
}

// allocStruct__DarwinX86DebugState64Memory allocates memory for type C.struct___darwin_x86_debug_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86DebugState64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86DebugState64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86DebugState64Value = unsafe.Sizeof([1]C.struct___darwin_x86_debug_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86DebugState64) Ref() *C.struct___darwin_x86_debug_state64 {
	if x == nil {
		return nil
	}
	return x.ref85d3ff91
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86DebugState64) Free() {
	if x != nil && x.allocs85d3ff91 != nil {
		x.allocs85d3ff91.(*cgoAllocMap).Free()
		x.ref85d3ff91 = nil
	}
}

// New_DarwinX86DebugState64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86DebugState64Ref(ref unsafe.Pointer) *_DarwinX86DebugState64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86DebugState64)
	obj.ref85d3ff91 = (*C.struct___darwin_x86_debug_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86DebugState64) PassRef() (*C.struct___darwin_x86_debug_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85d3ff91 != nil {
		return x.ref85d3ff91, nil
	}
	mem85d3ff91 := allocStruct__DarwinX86DebugState64Memory(1)
	ref85d3ff91 := (*C.struct___darwin_x86_debug_state64)(mem85d3ff91)
	allocs85d3ff91 := new(cgoAllocMap)
	allocs85d3ff91.Add(mem85d3ff91)

	var c__dr0_allocs *cgoAllocMap
	ref85d3ff91.__dr0, c__dr0_allocs = (C.__uint64_t)(x._Dr0), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr0_allocs)

	var c__dr1_allocs *cgoAllocMap
	ref85d3ff91.__dr1, c__dr1_allocs = (C.__uint64_t)(x._Dr1), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr1_allocs)

	var c__dr2_allocs *cgoAllocMap
	ref85d3ff91.__dr2, c__dr2_allocs = (C.__uint64_t)(x._Dr2), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr2_allocs)

	var c__dr3_allocs *cgoAllocMap
	ref85d3ff91.__dr3, c__dr3_allocs = (C.__uint64_t)(x._Dr3), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr3_allocs)

	var c__dr4_allocs *cgoAllocMap
	ref85d3ff91.__dr4, c__dr4_allocs = (C.__uint64_t)(x._Dr4), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr4_allocs)

	var c__dr5_allocs *cgoAllocMap
	ref85d3ff91.__dr5, c__dr5_allocs = (C.__uint64_t)(x._Dr5), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr5_allocs)

	var c__dr6_allocs *cgoAllocMap
	ref85d3ff91.__dr6, c__dr6_allocs = (C.__uint64_t)(x._Dr6), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr6_allocs)

	var c__dr7_allocs *cgoAllocMap
	ref85d3ff91.__dr7, c__dr7_allocs = (C.__uint64_t)(x._Dr7), cgoAllocsUnknown
	allocs85d3ff91.Borrow(c__dr7_allocs)

	x.ref85d3ff91 = ref85d3ff91
	x.allocs85d3ff91 = allocs85d3ff91
	return ref85d3ff91, allocs85d3ff91

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86DebugState64) PassValue() (C.struct___darwin_x86_debug_state64, *cgoAllocMap) {
	if x.ref85d3ff91 != nil {
		return *x.ref85d3ff91, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86DebugState64) Deref() {
	if x.ref85d3ff91 == nil {
		return
	}
	x._Dr0 = (uint64)(x.ref85d3ff91.__dr0)
	x._Dr1 = (uint64)(x.ref85d3ff91.__dr1)
	x._Dr2 = (uint64)(x.ref85d3ff91.__dr2)
	x._Dr3 = (uint64)(x.ref85d3ff91.__dr3)
	x._Dr4 = (uint64)(x.ref85d3ff91.__dr4)
	x._Dr5 = (uint64)(x.ref85d3ff91.__dr5)
	x._Dr6 = (uint64)(x.ref85d3ff91.__dr6)
	x._Dr7 = (uint64)(x.ref85d3ff91.__dr7)
}

// allocStruct__DarwinX86ExceptionState64Memory allocates memory for type C.struct___darwin_x86_exception_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86ExceptionState64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86ExceptionState64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86ExceptionState64Value = unsafe.Sizeof([1]C.struct___darwin_x86_exception_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86ExceptionState64) Ref() *C.struct___darwin_x86_exception_state64 {
	if x == nil {
		return nil
	}
	return x.refe6844d5e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86ExceptionState64) Free() {
	if x != nil && x.allocse6844d5e != nil {
		x.allocse6844d5e.(*cgoAllocMap).Free()
		x.refe6844d5e = nil
	}
}

// New_DarwinX86ExceptionState64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86ExceptionState64Ref(ref unsafe.Pointer) *_DarwinX86ExceptionState64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86ExceptionState64)
	obj.refe6844d5e = (*C.struct___darwin_x86_exception_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86ExceptionState64) PassRef() (*C.struct___darwin_x86_exception_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe6844d5e != nil {
		return x.refe6844d5e, nil
	}
	meme6844d5e := allocStruct__DarwinX86ExceptionState64Memory(1)
	refe6844d5e := (*C.struct___darwin_x86_exception_state64)(meme6844d5e)
	allocse6844d5e := new(cgoAllocMap)
	allocse6844d5e.Add(meme6844d5e)

	var c__trapno_allocs *cgoAllocMap
	refe6844d5e.__trapno, c__trapno_allocs = (C.__uint16_t)(x._Trapno), cgoAllocsUnknown
	allocse6844d5e.Borrow(c__trapno_allocs)

	var c__cpu_allocs *cgoAllocMap
	refe6844d5e.__cpu, c__cpu_allocs = (C.__uint16_t)(x._Cpu), cgoAllocsUnknown
	allocse6844d5e.Borrow(c__cpu_allocs)

	var c__err_allocs *cgoAllocMap
	refe6844d5e.__err, c__err_allocs = (C.__uint32_t)(x._Err), cgoAllocsUnknown
	allocse6844d5e.Borrow(c__err_allocs)

	var c__faultvaddr_allocs *cgoAllocMap
	refe6844d5e.__faultvaddr, c__faultvaddr_allocs = (C.__uint64_t)(x._Faultvaddr), cgoAllocsUnknown
	allocse6844d5e.Borrow(c__faultvaddr_allocs)

	x.refe6844d5e = refe6844d5e
	x.allocse6844d5e = allocse6844d5e
	return refe6844d5e, allocse6844d5e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86ExceptionState64) PassValue() (C.struct___darwin_x86_exception_state64, *cgoAllocMap) {
	if x.refe6844d5e != nil {
		return *x.refe6844d5e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86ExceptionState64) Deref() {
	if x.refe6844d5e == nil {
		return
	}
	x._Trapno = (uint16)(x.refe6844d5e.__trapno)
	x._Cpu = (uint16)(x.refe6844d5e.__cpu)
	x._Err = (uint32)(x.refe6844d5e.__err)
	x._Faultvaddr = (uint64)(x.refe6844d5e.__faultvaddr)
}

// allocStruct__DarwinX86FloatState64Memory allocates memory for type C.struct___darwin_x86_float_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86FloatState64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86FloatState64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86FloatState64Value = unsafe.Sizeof([1]C.struct___darwin_x86_float_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86FloatState64) Ref() *C.struct___darwin_x86_float_state64 {
	if x == nil {
		return nil
	}
	return x.ref8ba626a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86FloatState64) Free() {
	if x != nil && x.allocs8ba626a != nil {
		x.allocs8ba626a.(*cgoAllocMap).Free()
		x.ref8ba626a = nil
	}
}

// New_DarwinX86FloatState64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86FloatState64Ref(ref unsafe.Pointer) *_DarwinX86FloatState64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86FloatState64)
	obj.ref8ba626a = (*C.struct___darwin_x86_float_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86FloatState64) PassRef() (*C.struct___darwin_x86_float_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8ba626a != nil {
		return x.ref8ba626a, nil
	}
	mem8ba626a := allocStruct__DarwinX86FloatState64Memory(1)
	ref8ba626a := (*C.struct___darwin_x86_float_state64)(mem8ba626a)
	allocs8ba626a := new(cgoAllocMap)
	allocs8ba626a.Add(mem8ba626a)

	var c__fpu_reserved_allocs *cgoAllocMap
	ref8ba626a.__fpu_reserved, c__fpu_reserved_allocs = *(*[2]C.int)(unsafe.Pointer(&x._FpuReserved)), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_reserved_allocs)

	var c__fpu_fcw_allocs *cgoAllocMap
	ref8ba626a.__fpu_fcw, c__fpu_fcw_allocs = x._FpuFcw.PassValue()
	allocs8ba626a.Borrow(c__fpu_fcw_allocs)

	var c__fpu_fsw_allocs *cgoAllocMap
	ref8ba626a.__fpu_fsw, c__fpu_fsw_allocs = x._FpuFsw.PassValue()
	allocs8ba626a.Borrow(c__fpu_fsw_allocs)

	var c__fpu_ftw_allocs *cgoAllocMap
	ref8ba626a.__fpu_ftw, c__fpu_ftw_allocs = (C.__uint8_t)(x._FpuFtw), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_ftw_allocs)

	var c__fpu_rsrv1_allocs *cgoAllocMap
	ref8ba626a.__fpu_rsrv1, c__fpu_rsrv1_allocs = (C.__uint8_t)(x._FpuRsrv1), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_rsrv1_allocs)

	var c__fpu_fop_allocs *cgoAllocMap
	ref8ba626a.__fpu_fop, c__fpu_fop_allocs = (C.__uint16_t)(x._FpuFop), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_fop_allocs)

	var c__fpu_ip_allocs *cgoAllocMap
	ref8ba626a.__fpu_ip, c__fpu_ip_allocs = (C.__uint32_t)(x._FpuIp), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_ip_allocs)

	var c__fpu_cs_allocs *cgoAllocMap
	ref8ba626a.__fpu_cs, c__fpu_cs_allocs = (C.__uint16_t)(x._FpuCs), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_cs_allocs)

	var c__fpu_rsrv2_allocs *cgoAllocMap
	ref8ba626a.__fpu_rsrv2, c__fpu_rsrv2_allocs = (C.__uint16_t)(x._FpuRsrv2), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_rsrv2_allocs)

	var c__fpu_dp_allocs *cgoAllocMap
	ref8ba626a.__fpu_dp, c__fpu_dp_allocs = (C.__uint32_t)(x._FpuDp), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_dp_allocs)

	var c__fpu_ds_allocs *cgoAllocMap
	ref8ba626a.__fpu_ds, c__fpu_ds_allocs = (C.__uint16_t)(x._FpuDs), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_ds_allocs)

	var c__fpu_rsrv3_allocs *cgoAllocMap
	ref8ba626a.__fpu_rsrv3, c__fpu_rsrv3_allocs = (C.__uint16_t)(x._FpuRsrv3), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_rsrv3_allocs)

	var c__fpu_mxcsr_allocs *cgoAllocMap
	ref8ba626a.__fpu_mxcsr, c__fpu_mxcsr_allocs = (C.__uint32_t)(x._FpuMxcsr), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_mxcsr_allocs)

	var c__fpu_mxcsrmask_allocs *cgoAllocMap
	ref8ba626a.__fpu_mxcsrmask, c__fpu_mxcsrmask_allocs = (C.__uint32_t)(x._FpuMxcsrmask), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_mxcsrmask_allocs)

	var c__fpu_stmm0_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm0, c__fpu_stmm0_allocs = x._FpuStmm0.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm0_allocs)

	var c__fpu_stmm1_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm1, c__fpu_stmm1_allocs = x._FpuStmm1.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm1_allocs)

	var c__fpu_stmm2_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm2, c__fpu_stmm2_allocs = x._FpuStmm2.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm2_allocs)

	var c__fpu_stmm3_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm3, c__fpu_stmm3_allocs = x._FpuStmm3.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm3_allocs)

	var c__fpu_stmm4_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm4, c__fpu_stmm4_allocs = x._FpuStmm4.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm4_allocs)

	var c__fpu_stmm5_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm5, c__fpu_stmm5_allocs = x._FpuStmm5.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm5_allocs)

	var c__fpu_stmm6_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm6, c__fpu_stmm6_allocs = x._FpuStmm6.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm6_allocs)

	var c__fpu_stmm7_allocs *cgoAllocMap
	ref8ba626a.__fpu_stmm7, c__fpu_stmm7_allocs = x._FpuStmm7.PassValue()
	allocs8ba626a.Borrow(c__fpu_stmm7_allocs)

	var c__fpu_xmm0_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm0, c__fpu_xmm0_allocs = x._FpuXmm0.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm0_allocs)

	var c__fpu_xmm1_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm1, c__fpu_xmm1_allocs = x._FpuXmm1.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm1_allocs)

	var c__fpu_xmm2_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm2, c__fpu_xmm2_allocs = x._FpuXmm2.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm2_allocs)

	var c__fpu_xmm3_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm3, c__fpu_xmm3_allocs = x._FpuXmm3.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm3_allocs)

	var c__fpu_xmm4_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm4, c__fpu_xmm4_allocs = x._FpuXmm4.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm4_allocs)

	var c__fpu_xmm5_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm5, c__fpu_xmm5_allocs = x._FpuXmm5.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm5_allocs)

	var c__fpu_xmm6_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm6, c__fpu_xmm6_allocs = x._FpuXmm6.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm6_allocs)

	var c__fpu_xmm7_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm7, c__fpu_xmm7_allocs = x._FpuXmm7.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm7_allocs)

	var c__fpu_xmm8_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm8, c__fpu_xmm8_allocs = x._FpuXmm8.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm8_allocs)

	var c__fpu_xmm9_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm9, c__fpu_xmm9_allocs = x._FpuXmm9.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm9_allocs)

	var c__fpu_xmm10_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm10, c__fpu_xmm10_allocs = x._FpuXmm10.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm10_allocs)

	var c__fpu_xmm11_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm11, c__fpu_xmm11_allocs = x._FpuXmm11.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm11_allocs)

	var c__fpu_xmm12_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm12, c__fpu_xmm12_allocs = x._FpuXmm12.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm12_allocs)

	var c__fpu_xmm13_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm13, c__fpu_xmm13_allocs = x._FpuXmm13.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm13_allocs)

	var c__fpu_xmm14_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm14, c__fpu_xmm14_allocs = x._FpuXmm14.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm14_allocs)

	var c__fpu_xmm15_allocs *cgoAllocMap
	ref8ba626a.__fpu_xmm15, c__fpu_xmm15_allocs = x._FpuXmm15.PassValue()
	allocs8ba626a.Borrow(c__fpu_xmm15_allocs)

	var c__fpu_rsrv4_allocs *cgoAllocMap
	ref8ba626a.__fpu_rsrv4, c__fpu_rsrv4_allocs = *(*[96]C.char)(unsafe.Pointer(&x._FpuRsrv4)), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_rsrv4_allocs)

	var c__fpu_reserved1_allocs *cgoAllocMap
	ref8ba626a.__fpu_reserved1, c__fpu_reserved1_allocs = (C.int)(x._FpuReserved1), cgoAllocsUnknown
	allocs8ba626a.Borrow(c__fpu_reserved1_allocs)

	x.ref8ba626a = ref8ba626a
	x.allocs8ba626a = allocs8ba626a
	return ref8ba626a, allocs8ba626a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86FloatState64) PassValue() (C.struct___darwin_x86_float_state64, *cgoAllocMap) {
	if x.ref8ba626a != nil {
		return *x.ref8ba626a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86FloatState64) Deref() {
	if x.ref8ba626a == nil {
		return
	}
	x._FpuReserved = *(*[2]int32)(unsafe.Pointer(&x.ref8ba626a.__fpu_reserved))
	x._FpuFcw = *New_DarwinFpControlRef(unsafe.Pointer(&x.ref8ba626a.__fpu_fcw))
	x._FpuFsw = *New_DarwinFpStatusRef(unsafe.Pointer(&x.ref8ba626a.__fpu_fsw))
	x._FpuFtw = (byte)(x.ref8ba626a.__fpu_ftw)
	x._FpuRsrv1 = (byte)(x.ref8ba626a.__fpu_rsrv1)
	x._FpuFop = (uint16)(x.ref8ba626a.__fpu_fop)
	x._FpuIp = (uint32)(x.ref8ba626a.__fpu_ip)
	x._FpuCs = (uint16)(x.ref8ba626a.__fpu_cs)
	x._FpuRsrv2 = (uint16)(x.ref8ba626a.__fpu_rsrv2)
	x._FpuDp = (uint32)(x.ref8ba626a.__fpu_dp)
	x._FpuDs = (uint16)(x.ref8ba626a.__fpu_ds)
	x._FpuRsrv3 = (uint16)(x.ref8ba626a.__fpu_rsrv3)
	x._FpuMxcsr = (uint32)(x.ref8ba626a.__fpu_mxcsr)
	x._FpuMxcsrmask = (uint32)(x.ref8ba626a.__fpu_mxcsrmask)
	x._FpuStmm0 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm0))
	x._FpuStmm1 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm1))
	x._FpuStmm2 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm2))
	x._FpuStmm3 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm3))
	x._FpuStmm4 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm4))
	x._FpuStmm5 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm5))
	x._FpuStmm6 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm6))
	x._FpuStmm7 = *New_DarwinMmstRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_stmm7))
	x._FpuXmm0 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm0))
	x._FpuXmm1 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm1))
	x._FpuXmm2 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm2))
	x._FpuXmm3 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm3))
	x._FpuXmm4 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm4))
	x._FpuXmm5 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm5))
	x._FpuXmm6 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm6))
	x._FpuXmm7 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm7))
	x._FpuXmm8 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm8))
	x._FpuXmm9 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm9))
	x._FpuXmm10 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm10))
	x._FpuXmm11 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm11))
	x._FpuXmm12 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm12))
	x._FpuXmm13 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm13))
	x._FpuXmm14 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm14))
	x._FpuXmm15 = *New_DarwinXmmRegRef(unsafe.Pointer(&x.ref8ba626a.__fpu_xmm15))
	x._FpuRsrv4 = *(*[96]byte)(unsafe.Pointer(&x.ref8ba626a.__fpu_rsrv4))
	x._FpuReserved1 = (int32)(x.ref8ba626a.__fpu_reserved1)
}

// allocStruct__DarwinX86ThreadFullState64Memory allocates memory for type C.struct___darwin_x86_thread_full_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86ThreadFullState64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86ThreadFullState64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86ThreadFullState64Value = unsafe.Sizeof([1]C.struct___darwin_x86_thread_full_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86ThreadFullState64) Ref() *C.struct___darwin_x86_thread_full_state64 {
	if x == nil {
		return nil
	}
	return x.ref9e1a6f92
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86ThreadFullState64) Free() {
	if x != nil && x.allocs9e1a6f92 != nil {
		x.allocs9e1a6f92.(*cgoAllocMap).Free()
		x.ref9e1a6f92 = nil
	}
}

// New_DarwinX86ThreadFullState64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86ThreadFullState64Ref(ref unsafe.Pointer) *_DarwinX86ThreadFullState64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86ThreadFullState64)
	obj.ref9e1a6f92 = (*C.struct___darwin_x86_thread_full_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86ThreadFullState64) PassRef() (*C.struct___darwin_x86_thread_full_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e1a6f92 != nil {
		return x.ref9e1a6f92, nil
	}
	mem9e1a6f92 := allocStruct__DarwinX86ThreadFullState64Memory(1)
	ref9e1a6f92 := (*C.struct___darwin_x86_thread_full_state64)(mem9e1a6f92)
	allocs9e1a6f92 := new(cgoAllocMap)
	allocs9e1a6f92.Add(mem9e1a6f92)

	var c__ss64_allocs *cgoAllocMap
	ref9e1a6f92.__ss64, c__ss64_allocs = x._Ss64.PassValue()
	allocs9e1a6f92.Borrow(c__ss64_allocs)

	var c__ds_allocs *cgoAllocMap
	ref9e1a6f92.__ds, c__ds_allocs = (C.__uint64_t)(x._Ds), cgoAllocsUnknown
	allocs9e1a6f92.Borrow(c__ds_allocs)

	var c__es_allocs *cgoAllocMap
	ref9e1a6f92.__es, c__es_allocs = (C.__uint64_t)(x._Es), cgoAllocsUnknown
	allocs9e1a6f92.Borrow(c__es_allocs)

	var c__ss_allocs *cgoAllocMap
	ref9e1a6f92.__ss, c__ss_allocs = (C.__uint64_t)(x._Ss), cgoAllocsUnknown
	allocs9e1a6f92.Borrow(c__ss_allocs)

	var c__gsbase_allocs *cgoAllocMap
	ref9e1a6f92.__gsbase, c__gsbase_allocs = (C.__uint64_t)(x._Gsbase), cgoAllocsUnknown
	allocs9e1a6f92.Borrow(c__gsbase_allocs)

	x.ref9e1a6f92 = ref9e1a6f92
	x.allocs9e1a6f92 = allocs9e1a6f92
	return ref9e1a6f92, allocs9e1a6f92

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86ThreadFullState64) PassValue() (C.struct___darwin_x86_thread_full_state64, *cgoAllocMap) {
	if x.ref9e1a6f92 != nil {
		return *x.ref9e1a6f92, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86ThreadFullState64) Deref() {
	if x.ref9e1a6f92 == nil {
		return
	}
	x._Ss64 = *New_DarwinX86ThreadState64Ref(unsafe.Pointer(&x.ref9e1a6f92.__ss64))
	x._Ds = (uint64)(x.ref9e1a6f92.__ds)
	x._Es = (uint64)(x.ref9e1a6f92.__es)
	x._Ss = (uint64)(x.ref9e1a6f92.__ss)
	x._Gsbase = (uint64)(x.ref9e1a6f92.__gsbase)
}

// allocStruct__DarwinX86ThreadState64Memory allocates memory for type C.struct___darwin_x86_thread_state64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinX86ThreadState64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinX86ThreadState64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinX86ThreadState64Value = unsafe.Sizeof([1]C.struct___darwin_x86_thread_state64{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinX86ThreadState64) Ref() *C.struct___darwin_x86_thread_state64 {
	if x == nil {
		return nil
	}
	return x.ref723d30a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinX86ThreadState64) Free() {
	if x != nil && x.allocs723d30a4 != nil {
		x.allocs723d30a4.(*cgoAllocMap).Free()
		x.ref723d30a4 = nil
	}
}

// New_DarwinX86ThreadState64Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinX86ThreadState64Ref(ref unsafe.Pointer) *_DarwinX86ThreadState64 {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinX86ThreadState64)
	obj.ref723d30a4 = (*C.struct___darwin_x86_thread_state64)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinX86ThreadState64) PassRef() (*C.struct___darwin_x86_thread_state64, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref723d30a4 != nil {
		return x.ref723d30a4, nil
	}
	mem723d30a4 := allocStruct__DarwinX86ThreadState64Memory(1)
	ref723d30a4 := (*C.struct___darwin_x86_thread_state64)(mem723d30a4)
	allocs723d30a4 := new(cgoAllocMap)
	allocs723d30a4.Add(mem723d30a4)

	var c__rax_allocs *cgoAllocMap
	ref723d30a4.__rax, c__rax_allocs = (C.__uint64_t)(x._Rax), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rax_allocs)

	var c__rbx_allocs *cgoAllocMap
	ref723d30a4.__rbx, c__rbx_allocs = (C.__uint64_t)(x._Rbx), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rbx_allocs)

	var c__rcx_allocs *cgoAllocMap
	ref723d30a4.__rcx, c__rcx_allocs = (C.__uint64_t)(x._Rcx), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rcx_allocs)

	var c__rdx_allocs *cgoAllocMap
	ref723d30a4.__rdx, c__rdx_allocs = (C.__uint64_t)(x._Rdx), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rdx_allocs)

	var c__rdi_allocs *cgoAllocMap
	ref723d30a4.__rdi, c__rdi_allocs = (C.__uint64_t)(x._Rdi), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rdi_allocs)

	var c__rsi_allocs *cgoAllocMap
	ref723d30a4.__rsi, c__rsi_allocs = (C.__uint64_t)(x._Rsi), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rsi_allocs)

	var c__rbp_allocs *cgoAllocMap
	ref723d30a4.__rbp, c__rbp_allocs = (C.__uint64_t)(x._Rbp), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rbp_allocs)

	var c__rsp_allocs *cgoAllocMap
	ref723d30a4.__rsp, c__rsp_allocs = (C.__uint64_t)(x._Rsp), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rsp_allocs)

	var c__r8_allocs *cgoAllocMap
	ref723d30a4.__r8, c__r8_allocs = (C.__uint64_t)(x._R8), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r8_allocs)

	var c__r9_allocs *cgoAllocMap
	ref723d30a4.__r9, c__r9_allocs = (C.__uint64_t)(x._R9), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r9_allocs)

	var c__r10_allocs *cgoAllocMap
	ref723d30a4.__r10, c__r10_allocs = (C.__uint64_t)(x._R10), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r10_allocs)

	var c__r11_allocs *cgoAllocMap
	ref723d30a4.__r11, c__r11_allocs = (C.__uint64_t)(x._R11), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r11_allocs)

	var c__r12_allocs *cgoAllocMap
	ref723d30a4.__r12, c__r12_allocs = (C.__uint64_t)(x._R12), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r12_allocs)

	var c__r13_allocs *cgoAllocMap
	ref723d30a4.__r13, c__r13_allocs = (C.__uint64_t)(x._R13), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r13_allocs)

	var c__r14_allocs *cgoAllocMap
	ref723d30a4.__r14, c__r14_allocs = (C.__uint64_t)(x._R14), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r14_allocs)

	var c__r15_allocs *cgoAllocMap
	ref723d30a4.__r15, c__r15_allocs = (C.__uint64_t)(x._R15), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__r15_allocs)

	var c__rip_allocs *cgoAllocMap
	ref723d30a4.__rip, c__rip_allocs = (C.__uint64_t)(x._Rip), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rip_allocs)

	var c__rflags_allocs *cgoAllocMap
	ref723d30a4.__rflags, c__rflags_allocs = (C.__uint64_t)(x._Rflags), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__rflags_allocs)

	var c__cs_allocs *cgoAllocMap
	ref723d30a4.__cs, c__cs_allocs = (C.__uint64_t)(x._Cs), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__cs_allocs)

	var c__fs_allocs *cgoAllocMap
	ref723d30a4.__fs, c__fs_allocs = (C.__uint64_t)(x._Fs), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__fs_allocs)

	var c__gs_allocs *cgoAllocMap
	ref723d30a4.__gs, c__gs_allocs = (C.__uint64_t)(x._Gs), cgoAllocsUnknown
	allocs723d30a4.Borrow(c__gs_allocs)

	x.ref723d30a4 = ref723d30a4
	x.allocs723d30a4 = allocs723d30a4
	return ref723d30a4, allocs723d30a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinX86ThreadState64) PassValue() (C.struct___darwin_x86_thread_state64, *cgoAllocMap) {
	if x.ref723d30a4 != nil {
		return *x.ref723d30a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinX86ThreadState64) Deref() {
	if x.ref723d30a4 == nil {
		return
	}
	x._Rax = (uint64)(x.ref723d30a4.__rax)
	x._Rbx = (uint64)(x.ref723d30a4.__rbx)
	x._Rcx = (uint64)(x.ref723d30a4.__rcx)
	x._Rdx = (uint64)(x.ref723d30a4.__rdx)
	x._Rdi = (uint64)(x.ref723d30a4.__rdi)
	x._Rsi = (uint64)(x.ref723d30a4.__rsi)
	x._Rbp = (uint64)(x.ref723d30a4.__rbp)
	x._Rsp = (uint64)(x.ref723d30a4.__rsp)
	x._R8 = (uint64)(x.ref723d30a4.__r8)
	x._R9 = (uint64)(x.ref723d30a4.__r9)
	x._R10 = (uint64)(x.ref723d30a4.__r10)
	x._R11 = (uint64)(x.ref723d30a4.__r11)
	x._R12 = (uint64)(x.ref723d30a4.__r12)
	x._R13 = (uint64)(x.ref723d30a4.__r13)
	x._R14 = (uint64)(x.ref723d30a4.__r14)
	x._R15 = (uint64)(x.ref723d30a4.__r15)
	x._Rip = (uint64)(x.ref723d30a4.__rip)
	x._Rflags = (uint64)(x.ref723d30a4.__rflags)
	x._Cs = (uint64)(x.ref723d30a4.__cs)
	x._Fs = (uint64)(x.ref723d30a4.__fs)
	x._Gs = (uint64)(x.ref723d30a4.__gs)
}

// allocStruct__DarwinXmmRegMemory allocates memory for type C.struct___darwin_xmm_reg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinXmmRegMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinXmmRegValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinXmmRegValue = unsafe.Sizeof([1]C.struct___darwin_xmm_reg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinXmmReg) Ref() *C.struct___darwin_xmm_reg {
	if x == nil {
		return nil
	}
	return x.ref4ce4c564
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinXmmReg) Free() {
	if x != nil && x.allocs4ce4c564 != nil {
		x.allocs4ce4c564.(*cgoAllocMap).Free()
		x.ref4ce4c564 = nil
	}
}

// New_DarwinXmmRegRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinXmmRegRef(ref unsafe.Pointer) *_DarwinXmmReg {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinXmmReg)
	obj.ref4ce4c564 = (*C.struct___darwin_xmm_reg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinXmmReg) PassRef() (*C.struct___darwin_xmm_reg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ce4c564 != nil {
		return x.ref4ce4c564, nil
	}
	mem4ce4c564 := allocStruct__DarwinXmmRegMemory(1)
	ref4ce4c564 := (*C.struct___darwin_xmm_reg)(mem4ce4c564)
	allocs4ce4c564 := new(cgoAllocMap)
	allocs4ce4c564.Add(mem4ce4c564)

	var c__xmm_reg_allocs *cgoAllocMap
	ref4ce4c564.__xmm_reg, c__xmm_reg_allocs = *(*[16]C.char)(unsafe.Pointer(&x._XmmReg)), cgoAllocsUnknown
	allocs4ce4c564.Borrow(c__xmm_reg_allocs)

	x.ref4ce4c564 = ref4ce4c564
	x.allocs4ce4c564 = allocs4ce4c564
	return ref4ce4c564, allocs4ce4c564

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinXmmReg) PassValue() (C.struct___darwin_xmm_reg, *cgoAllocMap) {
	if x.ref4ce4c564 != nil {
		return *x.ref4ce4c564, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinXmmReg) Deref() {
	if x.ref4ce4c564 == nil {
		return
	}
	x._XmmReg = *(*[16]byte)(unsafe.Pointer(&x.ref4ce4c564.__xmm_reg))
}

// allocStruct__DarwinYmmRegMemory allocates memory for type C.struct___darwin_ymm_reg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinYmmRegMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinYmmRegValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinYmmRegValue = unsafe.Sizeof([1]C.struct___darwin_ymm_reg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinYmmReg) Ref() *C.struct___darwin_ymm_reg {
	if x == nil {
		return nil
	}
	return x.refea93ced0
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinYmmReg) Free() {
	if x != nil && x.allocsea93ced0 != nil {
		x.allocsea93ced0.(*cgoAllocMap).Free()
		x.refea93ced0 = nil
	}
}

// New_DarwinYmmRegRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinYmmRegRef(ref unsafe.Pointer) *_DarwinYmmReg {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinYmmReg)
	obj.refea93ced0 = (*C.struct___darwin_ymm_reg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinYmmReg) PassRef() (*C.struct___darwin_ymm_reg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refea93ced0 != nil {
		return x.refea93ced0, nil
	}
	memea93ced0 := allocStruct__DarwinYmmRegMemory(1)
	refea93ced0 := (*C.struct___darwin_ymm_reg)(memea93ced0)
	allocsea93ced0 := new(cgoAllocMap)
	allocsea93ced0.Add(memea93ced0)

	var c__ymm_reg_allocs *cgoAllocMap
	refea93ced0.__ymm_reg, c__ymm_reg_allocs = *(*[32]C.char)(unsafe.Pointer(&x._YmmReg)), cgoAllocsUnknown
	allocsea93ced0.Borrow(c__ymm_reg_allocs)

	x.refea93ced0 = refea93ced0
	x.allocsea93ced0 = allocsea93ced0
	return refea93ced0, allocsea93ced0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinYmmReg) PassValue() (C.struct___darwin_ymm_reg, *cgoAllocMap) {
	if x.refea93ced0 != nil {
		return *x.refea93ced0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinYmmReg) Deref() {
	if x.refea93ced0 == nil {
		return
	}
	x._YmmReg = *(*[32]byte)(unsafe.Pointer(&x.refea93ced0.__ymm_reg))
}

// allocStruct__DarwinZmmRegMemory allocates memory for type C.struct___darwin_zmm_reg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__DarwinZmmRegMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__DarwinZmmRegValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__DarwinZmmRegValue = unsafe.Sizeof([1]C.struct___darwin_zmm_reg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_DarwinZmmReg) Ref() *C.struct___darwin_zmm_reg {
	if x == nil {
		return nil
	}
	return x.refdb7bd44d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_DarwinZmmReg) Free() {
	if x != nil && x.allocsdb7bd44d != nil {
		x.allocsdb7bd44d.(*cgoAllocMap).Free()
		x.refdb7bd44d = nil
	}
}

// New_DarwinZmmRegRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_DarwinZmmRegRef(ref unsafe.Pointer) *_DarwinZmmReg {
	if ref == nil {
		return nil
	}
	obj := new(_DarwinZmmReg)
	obj.refdb7bd44d = (*C.struct___darwin_zmm_reg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_DarwinZmmReg) PassRef() (*C.struct___darwin_zmm_reg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb7bd44d != nil {
		return x.refdb7bd44d, nil
	}
	memdb7bd44d := allocStruct__DarwinZmmRegMemory(1)
	refdb7bd44d := (*C.struct___darwin_zmm_reg)(memdb7bd44d)
	allocsdb7bd44d := new(cgoAllocMap)
	allocsdb7bd44d.Add(memdb7bd44d)

	var c__zmm_reg_allocs *cgoAllocMap
	refdb7bd44d.__zmm_reg, c__zmm_reg_allocs = *(*[64]C.char)(unsafe.Pointer(&x._ZmmReg)), cgoAllocsUnknown
	allocsdb7bd44d.Borrow(c__zmm_reg_allocs)

	x.refdb7bd44d = refdb7bd44d
	x.allocsdb7bd44d = allocsdb7bd44d
	return refdb7bd44d, allocsdb7bd44d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _DarwinZmmReg) PassValue() (C.struct___darwin_zmm_reg, *cgoAllocMap) {
	if x.refdb7bd44d != nil {
		return *x.refdb7bd44d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_DarwinZmmReg) Deref() {
	if x.refdb7bd44d == nil {
		return
	}
	x._ZmmReg = *(*[64]byte)(unsafe.Pointer(&x.refdb7bd44d.__zmm_reg))
}

// allocStruct__X86InstructionStateMemory allocates memory for type C.struct___x86_instruction_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__X86InstructionStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__X86InstructionStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__X86InstructionStateValue = unsafe.Sizeof([1]C.struct___x86_instruction_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_X86InstructionState) Ref() *C.struct___x86_instruction_state {
	if x == nil {
		return nil
	}
	return x.ref37c5b7fe
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_X86InstructionState) Free() {
	if x != nil && x.allocs37c5b7fe != nil {
		x.allocs37c5b7fe.(*cgoAllocMap).Free()
		x.ref37c5b7fe = nil
	}
}

// New_X86InstructionStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_X86InstructionStateRef(ref unsafe.Pointer) *_X86InstructionState {
	if ref == nil {
		return nil
	}
	obj := new(_X86InstructionState)
	obj.ref37c5b7fe = (*C.struct___x86_instruction_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_X86InstructionState) PassRef() (*C.struct___x86_instruction_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37c5b7fe != nil {
		return x.ref37c5b7fe, nil
	}
	mem37c5b7fe := allocStruct__X86InstructionStateMemory(1)
	ref37c5b7fe := (*C.struct___x86_instruction_state)(mem37c5b7fe)
	allocs37c5b7fe := new(cgoAllocMap)
	allocs37c5b7fe.Add(mem37c5b7fe)

	var c__insn_stream_valid_bytes_allocs *cgoAllocMap
	ref37c5b7fe.__insn_stream_valid_bytes, c__insn_stream_valid_bytes_allocs = (C.int)(x._InsnStreamValidBytes), cgoAllocsUnknown
	allocs37c5b7fe.Borrow(c__insn_stream_valid_bytes_allocs)

	var c__insn_offset_allocs *cgoAllocMap
	ref37c5b7fe.__insn_offset, c__insn_offset_allocs = (C.int)(x._InsnOffset), cgoAllocsUnknown
	allocs37c5b7fe.Borrow(c__insn_offset_allocs)

	var c__out_of_synch_allocs *cgoAllocMap
	ref37c5b7fe.__out_of_synch, c__out_of_synch_allocs = (C.int)(x._OutOfSynch), cgoAllocsUnknown
	allocs37c5b7fe.Borrow(c__out_of_synch_allocs)

	var c__insn_bytes_allocs *cgoAllocMap
	ref37c5b7fe.__insn_bytes, c__insn_bytes_allocs = *(*[2380]C.__uint8_t)(unsafe.Pointer(&x._InsnBytes)), cgoAllocsUnknown
	allocs37c5b7fe.Borrow(c__insn_bytes_allocs)

	var c__insn_cacheline_allocs *cgoAllocMap
	ref37c5b7fe.__insn_cacheline, c__insn_cacheline_allocs = *(*[64]C.__uint8_t)(unsafe.Pointer(&x._InsnCacheline)), cgoAllocsUnknown
	allocs37c5b7fe.Borrow(c__insn_cacheline_allocs)

	x.ref37c5b7fe = ref37c5b7fe
	x.allocs37c5b7fe = allocs37c5b7fe
	return ref37c5b7fe, allocs37c5b7fe

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _X86InstructionState) PassValue() (C.struct___x86_instruction_state, *cgoAllocMap) {
	if x.ref37c5b7fe != nil {
		return *x.ref37c5b7fe, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_X86InstructionState) Deref() {
	if x.ref37c5b7fe == nil {
		return
	}
	x._InsnStreamValidBytes = (int32)(x.ref37c5b7fe.__insn_stream_valid_bytes)
	x._InsnOffset = (int32)(x.ref37c5b7fe.__insn_offset)
	x._OutOfSynch = (int32)(x.ref37c5b7fe.__out_of_synch)
	x._InsnBytes = *(*[2380]byte)(unsafe.Pointer(&x.ref37c5b7fe.__insn_bytes))
	x._InsnCacheline = *(*[64]byte)(unsafe.Pointer(&x.ref37c5b7fe.__insn_cacheline))
}

// allocStruct__X86PageinStateMemory allocates memory for type C.struct___x86_pagein_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct__X86PageinStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct__X86PageinStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfStruct__X86PageinStateValue = unsafe.Sizeof([1]C.struct___x86_pagein_state{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *_X86PageinState) Ref() *C.struct___x86_pagein_state {
	if x == nil {
		return nil
	}
	return x.ref95432405
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *_X86PageinState) Free() {
	if x != nil && x.allocs95432405 != nil {
		x.allocs95432405.(*cgoAllocMap).Free()
		x.ref95432405 = nil
	}
}

// New_X86PageinStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func New_X86PageinStateRef(ref unsafe.Pointer) *_X86PageinState {
	if ref == nil {
		return nil
	}
	obj := new(_X86PageinState)
	obj.ref95432405 = (*C.struct___x86_pagein_state)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *_X86PageinState) PassRef() (*C.struct___x86_pagein_state, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref95432405 != nil {
		return x.ref95432405, nil
	}
	mem95432405 := allocStruct__X86PageinStateMemory(1)
	ref95432405 := (*C.struct___x86_pagein_state)(mem95432405)
	allocs95432405 := new(cgoAllocMap)
	allocs95432405.Add(mem95432405)

	var c__pagein_error_allocs *cgoAllocMap
	ref95432405.__pagein_error, c__pagein_error_allocs = (C.int)(x._PageinError), cgoAllocsUnknown
	allocs95432405.Borrow(c__pagein_error_allocs)

	x.ref95432405 = ref95432405
	x.allocs95432405 = allocs95432405
	return ref95432405, allocs95432405

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x _X86PageinState) PassValue() (C.struct___x86_pagein_state, *cgoAllocMap) {
	if x.ref95432405 != nil {
		return *x.ref95432405, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *_X86PageinState) Deref() {
	if x.ref95432405 == nil {
		return
	}
	x._PageinError = (int32)(x.ref95432405.__pagein_error)
}

// copyPDoubleBytes copies the data from Go slice as *C.double.
func copyPDoubleBytes(slice *sliceHeader) (*C.double, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfDoubleValue) * slice.Len,
		Cap:  int(sizeOfDoubleValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.double)(mem0), allocs
}

// allocDoubleMemory allocates memory for type C.double in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDoubleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDoubleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfDoubleValue = unsafe.Sizeof([1]C.double{})

// allocFileMemory allocates memory for type C.FILE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFileMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFileValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFileValue = unsafe.Sizeof([1]C.FILE{})

// unpackArgSFile transforms a sliced Go data structure into plain C format.
func unpackArgSFile(x []File) (unpacked *C.FILE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocFileMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.FILE)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.FILE)(h.Data)
	return
}

// packSFile reads sliced Go data structure out from plain C format.
func packSFile(v []File, ptr0 *C.FILE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFileValue]C.FILE)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFileRef(unsafe.Pointer(&ptr1))
	}
}

// copyPInt32Bytes copies the data from Go slice as *C.int32_t.
func copyPInt32Bytes(slice *sliceHeader) (*C.int32_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfInt32Value) * slice.Len,
		Cap:  int(sizeOfInt32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int32_t)(mem0), allocs
}

// allocInt32Memory allocates memory for type C.int32_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocInt32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfInt32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfInt32Value = unsafe.Sizeof([1]C.int32_t{})

// allocPDoubleMemory allocates memory for type *C.double in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPDoubleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPDoubleValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPDoubleValue = unsafe.Sizeof([1]*C.double{})

// unpackArgSSFloat64 transforms a sliced Go data structure into plain C format.
func unpackArgSSFloat64(x [][]float64) (unpacked **C.double, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPDoubleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.double)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.double)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.double)(h.Data)
	return
}

// packSSFloat64 reads sliced Go data structure out from plain C format.
func packSSFloat64(v [][]float64, ptr0 **C.double) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.double)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}
